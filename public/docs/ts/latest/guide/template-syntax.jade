block includes
  include ../_util-fns
  - var _JavaScript = 'JavaScript';
  //- Double underscore means don't escape var, use !{__var}.
  - var __chaining_op = '<code>;</code> or <code>,</code>';
  - var __chaining_op_ko = '<code>;</code> 와 <code>,</code>';
  - var __new_op = '<code>new</code>';
  - var __objectAsMap = 'object';
  - var __objectAsMap_ko = '객체';

// The docs standard h4 style uppercases, making code terms unreadable. Override it.
style.
  h4 {font-size: 17px !important; text-transform: none !important;}
  .syntax { font-family: Consolas, 'Lucida Sans', Courier, sans-serif; color: black; font-size: 85%; }
  h4 .syntax { font-size: 100%; }

:marked
  Angular 애플리케이션은 Component 클래스 인스턴스(*컴포넌트*)와 사용자가 접하는 템플릿과의 상호작용을 통해 사용자가 보는 것과 할 수 있는 것을 관리합니다.

  The Angular application manages what the user sees and can do, achieving this through the interaction of a 
  component class instance (the *component*) and its user-facing template.

  모델-뷰-컨트롤러(MVC) 또는 모델-뷰-뷰모델(MVVM)에 대한 경험으로 얻은 컴포넌트/템플릿 이중성에 대해 잘 알고 있을 것입니다.
  Angular에서 컴포넌트는 컨트롤러/뷰 모델의 일부이며, 템플릿은 뷰를 나타냅니다.

  You may be familiar with the component/template duality from your experience with model-view-controller (MVC) or model-view-viewmodel (MVVM). 
  In Angular, the component plays the part of the controller/viewmodel, and the template represents the view.

a#toc
:marked
  ### 컨텐츠 테이블
  ### Table of contents
  이 가이드는 Angular 템플릿 구문의 기본 요소, 뷰를 구성하는 데 필요한 요소를 다룹니다.

  This guide covers the basic elements of the Angular template syntax, elements you'll need to construct the view:

  * [템플릿 내 HTML](#html)
  * [HTML in templates](#html)
  * [삽입법 ( <span class="syntax">{&#xfeff;{...}}</span> )](#interpolation)
  * [Interpolation ( <span class="syntax">{&#xfeff;{...}}</span> )](#interpolation)
  * [Template expressions](#template-expressions)
  * [템플릿 명령문(statement)](#template-statements)
  * [Template statements](#template-statements)
  * [바인딩 문법](#binding-syntax)
  * [Binding syntax](#binding-syntax)
  * [프러퍼티 바인딩( <span class="syntax">[property]</span> )](#property-binding)
  * [Property binding ( <span class="syntax">[property]</span> )](#property-binding)
  * [속성, 클래스, 스타일 바인딩](#other-bindings)
  * [Attribute, class, and style bindings](#other-bindings)
  * [이벤트 바인딩 ( <span class="syntax">(event)</span> )](#event-binding)
  * [Event binding ( <span class="syntax">(event)</span> )](#event-binding)
  * [양방향 데이터 바인딩 ( <span class="syntax">[(...)]</span> )](#two-way)
  * [Two-way data binding ( <span class="syntax">[(...)]</span> )](#two-way)
  * [내장 지시자](#directives)
  * [Built-in directives](#directives)
    
    * [속성 지시자](#attribute-directives)
    
      [Attribute directives](#attribute-directives)

      * [NgClass](#ngClass)

        [NgClass](#ngClass)

      * [NgStyle](#ngStyle)

        [NgStyle](#ngStyle)

      * [NgModel (<span class="syntax">[(ngModel)]</span>) ](#ngModel)

        [NgModel (<span class="syntax">[(ngModel)]</span>) ](#ngModel)

    * [구조 지시자](#structural-directives)

      [Structural directives](#structural-directives)

      * [NgIf](#ngIf)

        [NgIf](#ngIf)
      
      * [NgFor](#ngFor)

        [NgFor](#ngFor)

        * [템플릿 입력 변수](#template-input-variables)

          [Template input variables](#template-input-variables)
        
        * [세부구문](#microsyntax)

          [microsyntax](#microsyntax)
      
      * [NgSwitch 지시자](#ngSwitch)

        [The NgSwitch directives](#ngSwitch)

  * [템플릿 참조 변수 ( <span class="syntax">#var</span> )](#ref-vars)
  * [Template reference variables ( <span class="syntax">#var</span> )](#ref-vars)
  * [인풋, 아웃풋 프로퍼티 ( <span class="syntax">@Input</span> and <span class="syntax">@Output</span> )](#inputs-outputs)
  * [Input and output properties ( <span class="syntax">@Input</span> and <span class="syntax">@Output</span> )](#inputs-outputs)
  * [템플릿 표현식 연산자](#expression-operators)

    [Template expression operators](#expression-operators)

    * [파이프 ( <span class="syntax">|</span> )](#pipe)

      [pipe ( <span class="syntax">|</span> )](#pipe)

    * [안전 내비게이션 연산자 ( <span class="syntax">?.</span> )](#safe-navigation-operator)

      [safe navigation operator ( <span class="syntax">?.</span> )](#safe-navigation-operator)

  <live-example></live-example>는 이번 챕터에서 설명하는 코드조각과 구문의 모든 것을 설명하고 있습니다.

  The <live-example></live-example> 
  demonstrates all of the syntax and code snippets described in this guide.

.l-hr
a#html
:marked
  ## 템플릿 내 HTML
  ## HTML in templates

  HTML은 Angular 템플릿 언어입니다.
  [빠른시작](../quickstart.html) 애플리케이션은 순수 HTML 템플릿을 사용했습니다:

  HTML is the language of the Angular template. 
  The [QuickStart](../quickstart.html) application has a template that is pure HTML:

code-example(language="html" escape="html").
  <h1>Hello Angular</h1>

:marked
  거의 모든 HTML 구문이 유효한 템플릿 구문입니다. 
  `<script>` 엘리먼트는 주요 예외사항입니다; 
  스크립트 삽입(injection) 공격의 위험을 없애기 위해 금지되어 있습니다. 
  실제로, `<script>`는 그저 무시됩니다.

  Almost all HTML syntax is valid template syntax. 
  The `<script>` element is a notable exception; 
  it is forbidden, eliminating the risk of script injection attacks.
  In practice, `<script>` is ignored and a warning appears in the browser console.

  일부 합법적인 HTML은 템플릿에서 별 의미가 없습니다. 
  `<html>`, `<body>`, 그리고 `<base>` 엘리먼트는 우리의 레퍼토리에서 유용한 역할을 못합니다. 
  그 외 대부분은 사용 가능한 대상입니다.

  Some legal HTML doesn't make much sense in a template. 
  The `<html>`, `<body>`, and `<base>` elements have no useful role. 
  Pretty much everything else is fair game.

  새로운 엘리먼트와 속성처럼 보이는 컴포넌트와 지시자로 템플릿의 HTML 어휘(vocabulary)를 확장할 수 있습니다. 
  다음 섹션에서는 데이터 바인딩을 통해 어떻게 동적으로 DOM (Document Object Model) 값을 가져오고 설정하는지 배워보겠습니다.

  You can extend the HTML vocabulary of your templates with components and directives that appear as new elements and attributes. 
  In the following sections, you'll learn how to get and set DOM (Document Object Model) values dynamically through data binding.

  템플릿 HTML이 얼마나 풍부해 질 수 있는지 보기 위해 데이터 바인딩의 첫번째 형식 &mdash; 삽입식 &mdash;을 살펴보겠습니다.

  Begin with the first form of data binding&mdash;interpolation&mdash;to see how much richer template HTML can be.

a(href="#toc") back to top

.l-hr
a#interpolation
:marked
  ## 삽입식 ( <span class="syntax">{&#xfeff;{...}}</span> )
  ## Interpolation ( <span class="syntax">{&#xfeff;{...}}</span> )
  앞서 Angular 교육 중에 삽입식의 이중 중괄호, `{{`와 `}}`,를 보았습니다.

  You met the double-curly braces of interpolation, `{{` and `}}`, early in your Angular education.
+makeExample('template-syntax/ts/src/app/app.component.html', 'first-interpolation')(format=".")
:marked
  삽입식을 사용해 계산된 문자열을 HTML 엘리먼트 태그 사이나 속성 할당 안에 끼워 넣습니다.

  You use interpolation to weave calculated strings into the text between HTML element tags and within attribute assignments.

+makeExample('template-syntax/ts/src/app/app.component.html', 'title+image')(format=".")
:marked
  중괄호 사이에 들어가는 내용은 종종 컴포넌트 프로퍼티의 이름입니다. Angular는 문자열 값을
  그에 대응하는 컴포넌트 프로퍼티로 교체합니다. 위의 예에서, Angular는 `title`과 `heroImageUrl` 프로퍼티를 평가하고
  "빈 칸을 채웁니다", 첫 번째는 굵은 애플리케이션 제목을, 다음은 히어로 이미지를 표시합니다.

  The material between the braces is often the name of a component property. Angular replaces that name with the
  string value of the corresponding component property. In the example above, Angular evaluates the `title` and `heroImageUrl` properties
  and "fills in the blanks", first displaying a bold application title and then a heroic image.

  보다 일반적으로, 중괄호 사이의 내용은 **템플릿 표현식**으로 Angular가 먼저 **평가**를 하고 **문자열로 변환**하는 것입니다.
  다음 삽입식은 중괄호 안의 두 개의 숫자를 더하여 특징을 설명합니다.

  More generally, the material between the braces is a **template expression** that Angular first **evaluates**
  and then **converts to a string**. The following interpolation illustrates the point by adding the two numbers within braces:
+makeExample('template-syntax/ts/src/app/app.component.html', 'sum-1')(format=".")
:marked
  표현식은 `getValue()`를 사용한 것처럼, 주인 컴포넌트의 메소드를 호출할 수 있습니다:

  The expression can invoke methods of the host component with `getVal()` as seen here:
+makeExample('template-syntax/ts/src/app/app.component.html', 'sum-2')(format=".")
:marked
  Angular는 이중 중괄호의 모든 표현식을 평가하고, 표현식의 결과를 문자열로 변환하고, 이웃 리터럴 문자열에 연결합니다.
  최종적으로, 이 복합 삽입 결과를 **엘리먼트나 지시자 속성**에 할당합니다.

  Angular evaluates all expressions in double curly braces, converts the expression results to strings, and links them with neighboring literal strings. Finally,
  it assigns this composite interpolated result to an **element or directive property**.

  마치 엘리먼트 태그 사이에 결과를 삽입하고 속성에 할당하는 것으로 보입니다.
  그렇게 생각하는 것이 편리하며, 실수로 고통을 겪지 않을 수 있습니다.
  비록 이것이 정확한 사실은 아니지만요. 삽입식은 Angular가
  [프로퍼티 바인딩](#property-binding)으로 변환하는 특별한 구문이며,
  아래에 설명되어 있습니다.

  You appear to be inserting the result between element tags and assigning it to attributes.
  It's convenient to think so, and you rarely suffer for this mistake.
  Though this is not exactly true. Interpolation is a special syntax that Angular converts into a
  [property binding](#property-binding), and is explained below.

  그러나 먼저, 템플릿 표현식과 명령문에 대해 자세히 살펴보겠습니다.

  But first, let's take a closer look at template expressions and statements.

a(href="#toc") back to top

.l-hr
a#template-expressions
:marked
  ## 템플릿 표현식
  ## Template expressions

  템플릿 **표현식**은 값을 생산합니다.
  Angular는 표현식을 실행하고 바인딩 타깃의 프로퍼티에 할당합니다;
  타깃은 HTML 엘리먼트, 컴포넌트, 또는 지시자일 수 있습니다.

  A template **expression** produces a value.
  Angular executes the expression and assigns it to a property of a binding target;
  the target might be an HTML element, a component, or a directive.

  `{{1 + 1}}`에서 삽입식 중괄호는 템플릿 표현식 `1 + 1`을 둘러쌉니다.
  아래의 [프로퍼티 바인딩](#property-binding) 섹션에서,
  템플릿 표현식은 `[프로퍼티]="표현식"` 처럼 `=` 기호의 오른쪽에 따옴표로 묶인 부분입니다.

  The interpolation braces in `{{1 + 1}}` surround the template expression `1 + 1`.
  In the [property binding](#property-binding) section below, 
  a template expression appears in quotes to the right of the&nbsp;`=` symbol as in `[property]="expression"`.

  템플릿 표현식은 #{_JavaScript}처럼 보이는 언어로 작성합니다.
  대부분의 #{_JavaScript} 표현식이 템플릿 표현식에서 유효합니다, 전부는 아니지만요.

  You write these template expressions in a language that looks like #{_JavaScript}.
  Many #{_JavaScript} expressions are legal template expressions, but not all.

  다음과 같이 부작용을 가지고 있거나 부작용을 유발하는 #{_JavaScript} 표현식은
  금지됩니다:

  #{_JavaScript} expressions that have or promote side effects are prohibited,
  including:

  * 할당 (`=`, `+=`, `-=`, ...)

  * assignments (`=`, `+=`, `-=`, ...)

  * !{__new_op}

  * !{__new_op}

  * !{__chaining_op_ko}을 사용한 연결 표현식

  * chaining expressions with !{__chaining_op}

  * 증가 연산자와 감소 연산자 (`++` 와 `--`)

  * increment and decrement operators (`++` and `--`)

:marked
  다른 #{_JavaScript} 구문과의 주목할만한 차이점은 다음과 같습니다:
  
  Other notable differences from #{_JavaScript} syntax include:

block notable-differences
  :marked
    * 비트 연산자 `|`와 `&`를 지원하지 않음

    * no support for the bitwise operators `|` and `&`

    * `|`나 `?.` 같은 새로운 [템플릿 표현식 연산자](#expression-operators)

    * new [template expression operators](#expression-operators), such as `|` and `?.`

h3#expression-context 표현식 컨텍스트
h3#expression-context Expression context
:marked
  *표현식 컨텍스트*는 일반적으로 _컴포넌트_ 인스턴스입니다. 
  다음 스니펫에서 이중 중괄호 안에 있는 `title`과 따옴표 안의 `isUnchanged`는 `AppComponent`의 속성을 참조합니다.

  The *expression context* is typically the _component_ instance.
  In the following snippets, the `title`  within double-curly braces and the
  `isUnchanged` in quotes refer to properties of the `AppComponent`.

+makeExample('template-syntax/ts/src/app/app.component.html', 'context-component-expression')(format=".")
:marked
  표현식은 [템플릿 입력 변수](#template-input-variable) (`let hero`) 또는 [템플릿 참조 변수](#ref-vars) (` # heroInput`)와 같은 템플릿 컨텍스트의 속성을 참조할 수도 있습니다.

  An expression may also refer to properties of the _template's_ context
  such as a [template input variable](#template-input-variable) (`let hero`)
  or a [template reference variable](#ref-vars) (`#heroInput`).
+makeExample('template-syntax/ts/src/app/app.component.html', 'context-var')(format=".")
:marked
  표현식에서 용어에 대한 컨텍스트는 _템플릿 변수_, 지시문의 _컨텍스트_ 객체 및 컴포넌트의 _구성요소_를 혼합한 것입니다.
  이러한 네임 스페이스 중 둘 이상에 속하는 이름을 참조하는 경우, 템플릿 변수 이름이 우선하며 그 뒤에 지시자의 _컨텍스트_에서 이름이오고 마지막으로 컴포넌트의 멤버 이름이 옵니다.

  The context for terms in an expression is a blend of the _template variables_, 
  the directive's _context_ object (if it has one), and the component's _members_.
  If you reference a name that belongs to more than one of these namespaces,
  the template variable name takes precedence, followed by a name in the directive's' _context_,
  and, lastly, the component's member names.

  앞의 예는 이러한 이름 충돌을 나타냅니다. 구성 요소에는 `hero` 속성이 있고 `*ngFor`는 `hero` 템플릿 변수를 정의합니다. 
  `{{hero}}`의 `hero`는 템플릿의 입력 변수를 나타내며 컴포넌트의 속성은 참조하지 않습니다.

  The previous example presents such a name collision. 
  The component has a `hero` property and the `*ngFor` defines a `hero` template variable. The `hero` in `{{hero}}` refers to the template input variable, not the component's property.

block template-expressions-cannot
  :marked
    Template expressions cannot refer to anything in
    the global namespace. They can't refer to `window` or `document`. They
    can't call `console.log` or `Math.max`. They are restricted to referencing
    members of the expression context.
    
    Template expressions cannot refer to anything in
    the global namespace. They can't refer to `window` or `document`. They
    can't call `console.log` or `Math.max`. They are restricted to referencing
    members of the expression context.

a(href="#toc") back to top

a#no-side-effects
a#expression-guidelines
:marked
  ### 표현식 가이드라인
  ### Expression guidelines

  템플릿 표현식은 애플리케이션을 완성할 수도 깨지게 할 수도 있습니다.
  부디 다음 가이드라인을 따르세요:

  Template expressions can make or break an application.
  Please follow these guidelines:

  * [표시 부작용 제거](#no-visible-side-effects)

  * [No visible side effects](#no-visible-side-effects)

  * [빠른 실행](#quick-execution)

  * [Quick execution](#quick-execution)

  * [단순함](#simplicity)

  * [Simplicity](#simplicity)

  * [멱등성(idempotence)](#idempotence)

  * [Idempotence](#idempotence)

  이 가이드라인의 유일한 예외는 완벽히 이해를 하고 있는 특별한 상황이어야 합니다.

  The only exceptions to these guidelines should be in specific circumstances that you thoroughly understand.

  #### 표시 부작용 제거
  #### No visible side effects

  템플릿 표현식은 타깃 프로퍼티의 값 외에는 어떤 애플리케이션 상태도
  변경해서는 안됩니다.

  A template expression should not change any application state other than the value of the
  target property.

  이것은 Angular의 "단방향성 데이터 흐름" 정책에 중요한 원칙입니다.
  컴포넌트의 값을 읽는 것이 다른 표시 값을 변경할 수 있다는 염려를 하지 않을 수 있어야 합니다.
  뷰는 단일 렌더링 단계를 통틀어 안정되어야 합니다.

  This rule is essential to Angular's "unidirectional data flow" policy.
  You should never worry that reading a component value might change some other displayed value.
  The view should be stable throughout a single rendering pass.

  #### 빠른 실행
  #### Quick execution
  Angular는 모든 변화 감지 사이클 후에 템플릿 표현식을 실행합니다.
  변화 감지 사이클은 프로미스 해결, http 결과, 타이머 이벤트, 키 누르기 및 마우스 이동과 같은 많은 비동기 활동에 의해 트리거됩니다.

  Angular executes template expressions after every change detection cycle.
  Change detection cycles are triggered by many asynchronous activities such as 
  promise resolutions, http results, timer events, keypresses and mouse moves.

  표현식은 빠르게 끝나야하며, 특히 느린 기기의 경우 사용자 경험이 좋지 않을 수 있습니다.
  계산결과가 비쌀 때 다른 값에서 계산된 캐시값을 고려하세요.

  Expressions should finish quickly or the user experience may drag, especially on slower devices.
  Consider caching values computed from other values when the computation is expensive.

  #### 단순함 
  #### Simplicity
  비록 매우 복잡한 템플릿 표현식을 작성할 수는 있지만, 그렇게 하지 않아야 합니다.

  Although it's possible to write quite complex template expressions, you should avoid them.

  프로퍼티 이름이나 메소드 호출은 표준을 따라야 합니다.
  때때로 사용하는 불리언 부정 (`!`)은 괜찮습니다.
  한편, 애플리케이션과 비즈니스 로직을 컴포넌트 자체에 한정해야 하고,
  그곳에서 개발 및 테스트를 쉽게 할 수 있어야 합니다.

  A property name or method call should be the norm.
  An occasional Boolean negation (`!`) is OK.
  Otherwise, confine application and business logic to the component itself,
  where it will be easier to develop and test.

  #### 멱등성(idempotence)
  #### Idempotence

  [멱등](https://en.wikipedia.org/wiki/Idempotence) 표현식은 이상적인 것입니다.
  왜냐하면 부작용에서 자유로와 Angular의 변경 탐지 성능을 개선시키기 때문입니다.

  An [idempotent](https://en.wikipedia.org/wiki/Idempotence) expression is ideal because
  it is free of side effects and improves Angular's change detection performance.

  Angular 용어에서 멱등 표현식은 그것에 종속된 값이 변경되지 않는한
  항상 *완전히 똑같은 것*을 반환합니다.

  In Angular terms, an idempotent expression always returns *exactly the same thing* until
  one of its dependent values changes.
:marked
  이벤트 루프의 단일 단계 중에는 종속된 값이 변경되지 않아야 합니다.
  만약 멱등 표현식이 문자열이나 숫자를 반환한다면, 연속으로 두번을 호출할 때
  같은 문자열이나 숫자를 반환합니다. 만약 표현식이 객체를 반환한다면 (배열을 포함해),
  연속으로 두번을 호출할 때 같은 객체 *참조*를 반환합니다.

  Dependent values should not change during a single turn of the event loop.
  If an idempotent expression returns a string or a number, it returns the same string or number
  when called twice in a row. If the expression returns an object (including #{_an} `#{_Array}`),
  it returns the same object *reference* when called twice in a row.

a(href="#toc") back to top

.l-hr
a#template-statements
:marked
  ## 템플릿 명령문
  ## Template statements

  템플릿 **명령문**은 엘리먼트, 컴포넌트, 또는 지시자와 같은
  바인딩 타깃에서 발생하는 **이벤트**에 반응합니다.
  [이벤트 바인딩](#event-binding) 섹션에서 템플릿 명령문을 살펴볼 것입니다.
  `(event)="statement"`처럼 `=` 기호의 오른쪽에 따옴표로 묶인 부분입니다.

  A template **statement** responds to an **event** raised by a binding target
  such as an element, component, or directive.
  You'll see template statements in the [event binding](#event-binding) section,
  appearing in quotes to the right of the `=`&nbsp;symbol as in `(event)="statement"`.


+makeExample('template-syntax/ts/src/app/app.component.html', 'context-component-statement')(format=".")
:marked
  템플릿 명령문에는 *부작용*이 있습니다.
  그것이 사건의 핵심입니다.
  사용자 동작에서 애플리케이션 상태를 업데이트하는 방법입니다.

  A template statement *has a side effect*.
  That's the whole point of an event.
  It's how you update application state from user action.

  이벤트에 응답하는 것은 Angular의 "단방향성 데이터 흐름"의 또 다른 측면입니다.
  이벤트 루프의 이 단계 중에는 어떤 것이든, 어디서든 자유롭게 변경할 수 있습니다.

  Responding to events is the other side of Angular's "unidirectional data flow".
  You're free to change anything, anywhere, during this turn of the event loop.

  템플릿 표현식처럼, 템플릿 *명령문*은 #{_JavaScript}처럼 보이는 언어를 사용합니다.
  템플릿 명령문 파서는 템플릿 표현식 파서와 다릅니다.
  특히 기본 할당 (`=`)과 표현식 연결 (!{__chaining_op}을 사용)을 지원합니다.

  Like template expressions, template *statements* use a language that looks like #{_JavaScript}.
  The template statement parser is different than the template expression parser and
  specifically supports both basic assignment (`=`) and chaining expressions 
  (with !{__chaining_op}).

  하지만, 일부 #{_JavaScript} 구문은 허용되지 않습니다:

  However, certain #{_JavaScript} syntax is not allowed:

  * !{__new_op}

  * !{__new_op}

  * 증가와 감소 연산자, `++` 와 `--`

  * increment and decrement operators, `++` and `--`

  * `+=` 와 `-=` 같은 연산자 할당

  * operator assignment, such as `+=` and `-=`

  * 비트 연산자 `|` 와 `&`

  * the bitwise operators `|` and `&`

  * [템플릿 표현식 연산자](#expression-operators)

  * the [template expression operators](#expression-operators)

:marked
  ### 명령문 컨텍스트
  ### Statement context

  표현식과 같이 명령문은 오직 명령문 컨텍스트 안에 있는 것(컴포넌트 인스턴스의 이벤트 핸들링 메소드 등)만 참조할 수 있습니다.

  As with expressions, statements can refer only to what's in the statement context
  such as an event handling method of the component instance.

:marked
  *명령문 컨텍스트*는 일반적으로 컴포넌트 인스턴스입니다.
  `(click)="deleteHero()"`의 *deleteHero*는 데이터 바인딩된 컴포넌트의 메소드입니다.

  The *statement context* is typically the component instance. 
  The *deleteHero* in `(click)="deleteHero()"` is a method of the data-bound component.
+makeExample('template-syntax/ts/src/app/app.component.html', 'context-component-statement')(format=".")

:marked
  명령 컨텍스트는 템플릿 자체 컨텍스트의 특성을 참조 할 수도 있습니다. 
  다음 예에서, 템플릿 `$event` 객체, [템플릿 입력 변수](# 템플릿 입력 변수) (`let hero`), [템플릿 참조 변수](#ref-vars) (`#heroForm`)는 컴포넌트의 이벤트 처리 메소드에 전달됩니다.

  The statement context may also refer to properties of the template's own context.
  In the following examples, the template `$event` object,
  a [template input variable](#template-input-variable) (`let hero`),
  and a [template reference variable](#ref-vars) (`#heroForm`)
  are passed to an event handling method of the component.
+makeExample('template-syntax/ts/src/app/app.component.html', 'context-var-statement')(format=".")
:marked
  템플릿 컨텍스트 이름은 컴포넌트 컨텍스트 이름보다 우선합니다.
  위의 `deleteHero(hero)`에서 `hero`는 템플릿 입력 변수이고, 컴포넌트의 `hero` 속성은 아닙니다.

  Template context names take precedence over component context names.
  In `deleteHero(hero)` above, the `hero` is the template input variable, not the component's `hero` property.

block statement-context
  :marked
    템플릿 명령문은 전역 네임스페이스에 있는 어떤 것도
    참조할 수 없습니다. `window`나 `document` 같은 것을 참조할 수 없습니다.
    `console.log`나 `Math.max` 같은 것을 호출 할 수 없습니다.

    Template statements cannot refer to anything in the global namespace. They
    can't refer to `window` or `document`. 
    They can't call `console.log` or `Math.max`.

:marked
  ### 명령문 가이드라인
  ### Statement guidelines

  표현식과 마찬가지로, 복잡한 템플릿 명령문을 피하세요.
  메소드 호출이나 간단한 프로퍼티 할당은 표준을 따라야 합니다.

  As with expressions, avoid writing complex template statements.
  A method call or simple property assignment should be the norm.

  이제 우리는 템플릿 표현식과 명령문의 맛을 보았으므로,
  삽입식을 넘어 다양한 데이터 바인딩 구문을 배울 준비가 되었습니다.

  Now that you have a feel for template expressions and statements,
  you're ready to learn about the varieties of data binding syntax beyond interpolation.

a(href="#toc") back to top

.l-hr
a#binding-syntax
:marked
  ## 바인딩 구문: 개요 
  ## Binding syntax: An overview

  데이터 바인딩은 사용자가 보는 것을 애플리케이션 데이터 값으로 조정하기 위한 메커니즘입니다.
  비록 HTML에서 값을 가져오고 보낼 수 있지만,
  만약 이러한 성가신 일을 바인딩 프레임워크에 위임할 수 있다면 애플리케이션을 작성하고, 읽고, 유지 관리하기가 보다 수월해집니다.
  우리는 그저 바인딩할 소스와 타깃 HTML 엘리먼트 사이에 바인딩을 선언하고 프레임워크가 일을 하게 하면 됩니다.

  Data binding is a mechanism for coordinating what users see with application data values.
  While you could push values to and pull values from HTML,
  the application is easier to write, read, and maintain if you turn these chores over to a binding framework.
  You simply declare bindings between binding sources and target HTML elements and let the framework do the work.

  Angular는 다양한 데이터 바인딩을 제공합니다.
  이 가이드에서는 Angular 데이터 바인딩 및 구문에 대한 고급 수준을 설명한 후 대부분을 다루고 있습니다.

  Angular provides many kinds of data binding. 
  This guide covers most of them, after a high-level view of Angular data binding and its syntax.

  바인딩 타입은 데이터 흐름 방향에 따라 구별되는 세 가지 범주로 그룹화 할 수 있습니다.
  _source-to-view_, _view-to-source_ 및 양방향 시퀀스: _view-to-source-to-view_.

  Binding types can be grouped into three categories distinguished by the direction of data flow:
  from the _source-to-view_, from _view-to-source_, and in the two-way sequence: _view-to-source-to-view_.
  :
style td, th {vertical-align: top}
table(width="100%")
  col(width="30%")
  col(width="50%")
  col(width="20%")
  tr
    th
      p 데이터 방향
      p Data direction
    th
      p 구문
      p Syntax
    th
      p 유형
      p Type
  tr
    td
      p 단방향
      p One-way
      p 데이터 소스에서
      p from data source
      p 뷰 타깃으로
      p to view target
    td
      code-example().
        {{expression}}
        [target] = "expression"
        bind-target = "expression"
    td
      p 삽입식
      p Interpolation
      p 프로퍼티
      p Property
      p 속성
      p Attribute
      p 클래스
      p Class
      p 스타일
      p Style
    tr
      td
        p 단방향
        p One-way
        p 뷰 타깃에서
        p from view target
        p 데이터 소스로
        p to data source
      td
        code-example().
          (target) = "statement"
          on-target = "statement"
      td
        p 이벤트
        p Event
    tr
      td
        p 양방향
        p Two-way
      td
        code-example().
          [(target)] = "expression"
          bindon-target = "expression"
      td
        p 양방향
        p Two-way

:marked
  삽입식 이외의 바인딩 유형은 등호의 왼쪽에 **타깃 이름**을 가집니다,
  이것들은 구두점 (`[]`, `()`)으로 둘러싸이거나 접두어 (`bind-`, `on-`, `bindon-`)가 있습니다.

  Binding types other than interpolation have a **target name** to the left of the equal sign,
  either surrounded by punctuation (`[]`, `()`) or preceded by a prefix (`bind-`, `on-`, `bindon-`).

  대상 이름은 _프로퍼티_의 이름입니다. 그것은 _속성_의 이름처럼 보일지 모르지만 그것은 결코 존재하지 않습니다.
  차이점을 이해하려면 템플릿 HTML에 대해 생각해 볼 수있는 새로운 방법을 개발해야합니다.

  The target name is the name of a _property_. It may look like the name of an _attribute_ but it never is.
  To appreciate the difference, you must develop a new way to think about template HTML.

  ### 새로운 멘탈 모델 (역주: 사용자가 제품을 이해하는 방식을 뜻하는 용어)
  ### A new mental model

  모든 데이터 바인딩과 사용자 정의 마크업으로 HTML 어휘를 확장하는 능력을 보면,
  템플릿 HTML을 *HTML Plus*로 생각할 수 있습니다.
  
  With all the power of data binding and the ability to extend the HTML vocabulary
  with custom markup, it is tempting to think of template HTML as *HTML Plus*.

  그렇습니다. 그것은 HTML Plus *입니다*.
  그러나 그것은 또한 우리가 사용해왔던 HTML과는 완전히 다릅니다.
  우리는 새로운 멘탈 모델이 필요합니다.

  It really *is* HTML Plus.
  But it's also significantly different than the HTML you're used to.
  It requires a new mental model.

  일반적인 HTML 개발 과정에서, 우리는 HTML 엘리먼트로 비주얼 구조를 만들고,
  엘리먼트 속성에 문자열 상수를 설정하여 그러한 엘리먼트를 수정합니다.

  In the normal course of HTML development, you create a visual structure with HTML elements, and
  you modify those elements by setting element attributes with string constants.

+makeExample('template-syntax/ts/src/app/app.component.html', 'img+button')(format=".")
:marked
  여전히 Angular 템플릿에서 구조를 만들고 속성 값을 초기화 합니다.
  
  You still create a structure and initialize attribute values this way in Angular templates.

  그런 다음, HTML을 캡슐화하는 컴포넌트로 새로운 엘리먼트를 만들고
  마치 그것들이 네이티브 HTML 엘리먼트인 것처럼 템플릿에 놓았습니다.

  Then you learn to create new elements with components that encapsulate HTML
  and drop them into templates as if they were native HTML elements.
+makeExample('template-syntax/ts/src/app/app.component.html', 'hero-detail-1')(format=".")
:marked
  이것이 HTML Plus 입니다.

  That's HTML Plus.

  이제 데이터 바인딩을 배워보겠습니다. 첫 번째 만날 바인딩은 다음과 같습니다:

  Then you learn about data binding. The first binding you meet might look like this:

+makeExample('template-syntax/ts/src/app/app.component.html', 'disabled-button-1')(format=".")
:marked
  특유의 대괄호 표기법을 잠깐 살펴보겠습니다. 그것을 넘어서,
  우리는 직감으로는 버튼의 `disabled` 속성에 바인딩하고,
  그것을 `isUnchanged` 컴포넌트 프로퍼티의 현재 값으로 설정할 것 같습니다.
  
  You'll get to that peculiar bracket notation in a moment. Looking beyond it,
  your intuition suggests that you're binding to the button's `disabled` attribute and setting
  it to the current value of the component's `isUnchanged` property.

  우리의 직감이 틀렸습니다! 일상적인 HTML 멘탈 모델이 우리를 오해하게 만들었습니다.
  사실, 데이터 바인딩을 시작하면 더 이상 HTML *속성*과 작업을 하지 않습니다. 우리는 속성을 설정하지 않습니다.
  우리는 DOM 엘리먼트, 컴포넌트, 그리고 지시자의 *속성*을 설정합니다.

  Your intuition is incorrect! Your everyday HTML mental model is misleading.
  In fact, once you start data binding, you are no longer working with HTML *attributes*. You aren't setting attributes.
  You are setting the *properties* of DOM elements, components, and directives.

.l-sub-section
  :marked
    ### HTML 속성 vs DOM 프로퍼티
    ### HTML attribute vs. DOM property

    HTML 속성과 DOM 프로퍼티의 차이는 Angular 바인딩이 어떻게 동작하는지 이해하는데 매우 중요합니다.

    The distinction between an HTML attribute and a DOM property is crucial to understanding how Angular binding works.

    **속성은 HTML에 의해 정의됩니다. 프로퍼티는 DOM (Document Object Model)에 의해 정의됩니다.**

    **Attributes are defined by HTML. Properties are defined by the DOM (Document Object Model).**

    * 일부 HTML 속성은 프로퍼티와 1:1 매핑됩니다. `id`가 한 예입니다.

    * A few HTML attributes have 1:1 mapping to properties. `id` is one example.

    * 일부 HTML 속성은 대응하는 프로퍼티가 없습니다. `colspan`이 한 예입니다.

    * Some HTML attributes don't have corresponding properties. `colspan` is one example.

    * 일부 DOM 프로퍼티는 대응하는 속성이 없습니다. `textContent`가 한 예입니다.

    * Some DOM properties don't have corresponding attributes. `textContent` is one example.

    * 많은 HTML 속성은 프로퍼티에 대응됩니다 ... 그러나 우리가 생각하는 방식은 아닙니다.

    * Many HTML attributes appear to map to properties ... but not in the way you might think!

    이런 일반적인 규칙을 이해하기 전까지 마지막 카테고리는 특히 헷갈릴 수 있습니다:

    That last category is confusing until you grasp this general rule:

    **속성은 DOM 프로퍼티를 *초기화* 한 다음 완료됩니다.
    프로퍼티 값은 변합니다; 속성 값은 그렇지 않습니다.**

    **Attributes *initialize* DOM properties and then they are done.
    Property values can change; attribute values can't.**

    예를들어, 브라우저가 `<input type="text" value="Bob">`을 렌더링하면,
    "Bob"으로 *초기화 된* `value` 속성을 가진 DOM 노드를 생성합니다.

    For example, when the browser renders `<input type="text" value="Bob">`, it creates a
    corresponding DOM node with a `value` property *initialized* to "Bob".

    사용자가 "Sally"를 입력 상자에 입력하면, DOM 엘리먼트 `value` *프로퍼티*는 "Sally"가 됩니다.
    그러나 HTML `value` *속성*은 변경되지 않은 채로 남아있습니다.
    다음 처럼 입력 엘리먼트에 질의하여 확인할 수 있습니다: `input.getAttribute('value') // "Bob"을 반환`

    When the user enters "Sally" into the input box, the DOM element `value` *property* becomes "Sally".
    But the HTML `value` *attribute* remains unchanged as you discover if you ask the input element
    about that attribute: `input.getAttribute('value') // returns "Bob"`

    HTML 속성 `value`는 *초기* 값을 지정합니다; DOM `value` 프로퍼티는 *현재* 값입니다.

    The HTML attribute `value` specifies the *initial* value; the DOM `value` property is the *current* value.

    `disabled` 속성은 또다른 특수한 예입니다. `disabled` 버튼 *속성*의
    기본값은 `false`이므로 버튼은 활성화 되어 있습니다.
    만약 `disabled` *속성*을 추가하면, 그것의 존재만으로 버튼의 `disabled` *속성*은
    `true`로 초기화되어 버튼은 비활성화 됩니다.

    The `disabled` attribute is another peculiar example. A button's `disabled` *property* is
    `false` by default so the button is enabled.
    When you add the `disabled` *attribute*, its presence alone initializes the  button's `disabled` *property* to `true`
    so the button is disabled.

    `disabled` *속성*을 추가 및 제거하는 것으로 버튼을 비활성화 및 활성화 합니다. *속성*의 값은 관련이 없습니다,
    이것이 `<button disabled="false">Still Disabled</button>`처럼 작성하여 버튼을 활성화 할 수 없는 이유입니다.

    Adding and removing the `disabled` *attribute* disables and enables the button. The value of the *attribute* is irrelevant,
    which is why you cannot enable a button by writing `<button disabled="false">Still Disabled</button>`.

    버튼의 `disabled` *속성*을 설정하는 것은 (즉, Angular 바인딩을 사용하여) 버튼을 비활성화하거나 활성화 합니다.
    *프로퍼티*의 값이 중요한 것입니다.

    Setting the button's `disabled` *property*  (say, with an Angular binding) disables or enables the button.
    The value of the *property* matters.

    **HTML 속성과 DOM 프로퍼티는 같은 것이 아닙니다. 심지어 같은 이름을 가졌을때도요.**

    **The HTML attribute and the DOM property are not the same thing, even when they have the same name.**

:marked
  이 사실은 반복됩니다:

  This fact bears repeating:

  **템플릿 바인딩은 *프로퍼티*와 *이벤트*로 동작합니다, *속성*이 아닙니다.**

  **Template binding works with *properties* and *events*, not *attributes*.**

.callout.is-helpful
  header 속성이 없는 세상
  header A world without attributes
  :marked
    Angular 세계에서, 속성의 유일한 역할은 엘리먼트 및 지시자 상태를 초기화 하는 것입니다.
    우리는 데이터 바인딩 시 엘리먼트와 지시자 프로퍼티와 이벤트를 배타적으로 다룹니다.
    속성은 실질적으로 사용하지 않습니다.

    In the world of Angular, the only role of attributes is to initialize element and directive state.
    When you write a data binding, you're dealing exclusively with properties and events of the target object.
    HTML attributes effectively disappear.
:marked
  이러한 모델을 확실하게 염두에 두고, 바인딩 타깃에 대해 알아보려면 계속 읽으세요.

  With this model firmly in mind, read on to learn about binding targets.

  ### 바인딩 타깃
  ### Binding targets

  **데이터 바인딩의 타깃**은 DOM에 있는 어떤 것입니다.
  바인딩 타입에 따라, 타깃은 (엘리먼트 | 컴포넌트 | 지시자) 프로퍼티,
  (엘리먼트 | 컴포넌트 | 지시자) 이벤트, 또는 (가끔씩) 속성 이름입니다.
  다음 표에 요약했습니다:

  The **target of a data binding** is something in the DOM.
  Depending on the binding type, the target can be an
  (element | component | directive) property, an
  (element | component | directive) event, or (rarely) an attribute name.
  The following table summarizes:

//- If you update this table, UPDATE it in Dart & JS, too.
style td, th {vertical-align: top}
table(width="100%")
  col(width="10%")
  col(width="15%")
  col(width="75%")
  tr
    th
      p 유형
      p Type
    th
      p 타깃
      p Target
    th
      p 예
      p Examples
  tr
    td
      p 프로퍼티
      p Property
    td
      p 엘리먼트&nbsp;속성
      p Element&nbsp;property
      p 컴포넌트&nbsp;속성
      p Component&nbsp;property
      p 지시자&nbsp;속성
      p Directive&nbsp;property
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-syntax-1')(format=".")
  tr
    td
      p 이벤트
      p Event
    td
      p 엘리먼트&nbsp;이벤트
      p Element&nbsp;event
      p 컴포넌트&nbsp;이벤트
      p Component&nbsp;event
      p 지시자&nbsp;이벤트
      p Directive&nbsp;event
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-syntax-1')(format=".")
  tr
    td
      p 양방향
      p Two-way
    td
      p 이벤트와 프로퍼티
      p Event and property
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', '2-way-binding-syntax-1')(format=".")
  tr
    td
      p 속성
      p Attribute
    td
      p 속성
      p Attribute
      p (예외)
      p (the&nbsp;exception)
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', 'attribute-binding-syntax-1')(format=".")
  tr
    td
      p 클래스
      p Class
    td
      p <code>클래스</code> 프로퍼티
      p <code>class</code> property
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', 'class-binding-syntax-1')(format=".")
  tr
    td
      p 스타일
      p Style
    td
      p <code>스타일</code> 프로퍼티
      p <code>style</code> property
    td
      +makeExample('template-syntax/ts/src/app/app.component.html', 'style-binding-syntax-1')(format=".")
</div>

:marked
  이 넓은 관점을 염두하고, 바인딩 유형을 자세하게 볼 준비가 되었습니다.

  With this broad view in mind, you're ready to look at binding types in detail.

a(href="#toc") back to top

.l-hr
a#property-binding
:marked
  ## 프로퍼티 바인딩 ( <span class="syntax">[property]</span> )
  ## Property binding ( <span class="syntax">[property]</span> )
  템플릿 **속성 바인딩**을 작성하여 뷰 요소의 속성을 설정합니다.
  바인딩은 속성을 [템플릿 표현식](# template-expressions)의 값으로 설정합니다.

  Write a template **property binding** to set a property of a view element.
  The binding sets the property to the value of a [template expression](#template-expressions).

  가장 일반적인 프로퍼티 바인딩은 엘리먼트 프로퍼티를 컴포넌트 프로퍼티 값으로 설정하는 것입니다.
  예제는 이미지 엘리먼트의 `src` 프로퍼티를 컴포넌트의 `heroImageUrl` 프로퍼티에 바인딩합니다:

  The most common property binding sets an element property to a component property value. An example is
  binding the `src` property of an image element to a component's `heroImageUrl` property:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-1')(format=".")
:marked
  다른 예제는 컴포넌트가 `isUnchanged`라고 알려주면 버튼을 비활성화 합니다:

  Another example is disabling a button when the component says that it `isUnchanged`:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-2')(format=".")
:marked
  다른 것은 지시자의 프로퍼티를 설정합니다:

  Another is setting a property of a directive:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-3')(format=".")
:marked
  또 다른 것은 사용자 컴포넌트의 모델 프로퍼티를 설정합니다.
  (부모와 자식 컴포넌트가 통신하기 위한 뛰어난 방법)

  Yet another is setting the model property of a custom component (a great way
  for parent and child components to communicate):
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-4')(format=".")
:marked
  ### 단방향 *in*
  ### One-way *in*

  사람들은 종종 프로퍼티 바인딩을 *단방향 데이터 바인딩*이라고 묘사합니다.
  왜냐하면 값이, 컴포넌트의 데이터 프로퍼티에서 타깃 엘리먼트의 프로퍼티로, 한 방향으로 흐르기 때문입니다.

  People often describe property binding as *one-way data binding* because it flows a value in one direction,
  from a component's data property into a target element property.

  프로퍼티 바인딩을 사용하여 타깃 엘리먼트에서 값을 가져올 수 없습니다.
  타깃 엘리먼트의 프로퍼티를 _읽기_ 위해 바인딩 할 수 없습니다. 오직 _설정할_ 수만 있습니다.

  You cannot use property binding to pull values *out* of the target element.
  You can't bind to a property of the target element to _read_ it. You can only _set_ it.

.l-sub-section
  :marked
    유사하게, 프로퍼티 바인딩을 사용해 타깃 엘리먼트의 메소드를 *호출*할 수 없습니다.

    Similarly, you cannot use property binding to *call* a method on the target element.

    만약 엘리먼트에서 이벤트가 발생하면, [이벤트 바인딩](#event-binding)으로 그것들을 들을 수 있습니다.

    If the element raises events, you can listen to them with an [event binding](#event-binding).

    만약 타깃 엘리먼트 속성을 읽어야 하거나 그것의 메소드를 호출해야 한다면,
    다른 기술이 필요합니다.
    [ViewChild](../api/core/index/ViewChild-decorator.html) 와
    [ContentChild](../api/core/index/ContentChild-decorator.html)에 있는
    API 참조설명을 보세요.

    If you must read a target element property or call one of its methods,
    you'll need a different technique.
    See the API reference for
    [ViewChild](../api/core/index/ViewChild-decorator.html) and
    [ContentChild](../api/core/index/ContentChild-decorator.html).

:marked
  ### 바인딩 타깃
  ### Binding target
  닫혀 있는 대괄호 사이의 엘리먼트 프로퍼티는 타깃 프로퍼티를 식별합니다. 다음 코드의 타깃 프로퍼티는 이미지 엘리먼트의 `src` 프로퍼티입니다.

  An element property between enclosing square brackets identifies the target property. The target property in the following code is the image element's `src` property.

+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-1')(format=".")
:marked
  어떤 사람들은 *정규형*으로 알려진 `bind-` 접두어 방식을 선호합니다.

  Some people prefer the `bind-` prefix alternative, known as the *canonical form*:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-5')(format=".")
:marked
  타깃 이름은 다른 것의 이름으로 보이지만 항상 프로퍼티의 이름입니다. 
  `src`를 보면 아마 속성의 이름이라고 생각할 것입니다. 아닙니다. 그것은 이미지 엘리먼트 프로퍼티의 이름입니다.

  The target name is always the name of a property, even when it appears to be the name of something else. 
  You see `src` and may think it's the name of an attribute. No. It's the name of an image element property.

  엘리먼트 프로퍼티가 보다 일반적인 타깃일 것입니다.
  그러나 다음 예제에 있는 것처럼 Angular는
  알려진 이름의 지시자 프로퍼티인지 먼저 확인합니다.

  Element properties may be the more common targets,
  but Angular looks first to see if the name is a property of a known directive,
  as it is in the following example:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-3')(format=".")

.l-sub-section
  :marked
    기술적으로, Angular는 이름을 [input](#inputs-outputs)지시자에서 찾아봅니다,
    이것은 지시자의 `inputs` 배열이나 `@Input()`으로 장식된 프로퍼티에 나열한 프로퍼티 이름 중 하나입니다.
    이런 input을 지시자의 자체 프로퍼티에 매핑합니다.

    Technically, Angular is matching the name to a directive [input](#inputs-outputs),
    one of the property names listed in the directive's `inputs` array or a property decorated with `@Input()`.
    Such inputs map to the directive's own properties.
:marked
  만약 알려진 지사자나 엘리먼트에서 찾지 못하면, Angular는 “unknown directive”를 보고합니다.

  If the name fails to match a property of a known directive or element, Angular reports an “unknown directive” error.

  ### 부작용 회피
  ### Avoid side effects
  이미 논의한 것처럼, 템플릿 표현식 평가는 표시 부작용이 없어야 합니다.
  표현식 언어 자체는 우리를 안전하게 지켜주는 역할을 합니다.
  프로퍼티 바인딩 표현식의 어떤 것에도 값을 할당할 수 없고 증감 연산자도 사용할 수 없습니다.

  As mentioned previously, evaluation of a template expression should have no visible side effects. 
  The expression language itself does its part to keep you safe. 
  You can't assign a value to anything in a property binding expression nor use the increment and decrement operators.

  물론, 표현식은 부작용이 있는 프러퍼티나 메소드를 호출 할 수 있습니다.
  Angular가 이것을 알고 멈추게할 방법은 없습니다.

  Of course, the expression might invoke a property or method that has side effects. 
  Angular has no way of knowing that or stopping you.

  표현식은 `getFoo()`같은 것을 호출할 수 있습니다. 오직 당신만 `getFoo()`가 무엇을 하는지 알고 있습니다.
  만약 `getFoo()`가 무엇인가를 변경하고 그 무엇에 바인딩하면, 안 좋은 경험을 할 위험이 있습니다.
  Angular는 변경된 값을 표시할 수도 표시하지 않을 수도 있습니다. Angular는 변경을 감지하고 경고 에러를 던질 수도 있습니다.
  일반적으로 데이터 프로퍼티와 값을 반환하고 아무것도 하지 않는 메소드 사용을 고수하세요.

  The expression could call something like `getFoo()`. Only you know what `getFoo()` does.
  If `getFoo()` changes something and you happen to be binding to that something, you risk an unpleasant experience. 
  Angular may or may not display the changed value. Angular may detect the change and throw a warning error. 
  In general, stick to data properties and to methods that return values and do no more.

  ### 적절한 타입을 반환
  ### Return the proper type

  템플릿 표현식은 타깃 프로퍼티가 예상하는 값의 타입으로 평가되어야만 합니다.
  만약 타깃 프로퍼티가 문자열을 기대하고 있으면 문자열을 반환해야 합니다.
  만약 타깃 프로퍼티가 숫자를 기대하고 있으면 숫자를 반환해야 합니다.
  만약 타깃 프로퍼티가 객체를 기대하고 있으면 객체를 반환해야 합니다.

  The template expression should evaluate to the type of value expected by the target property.
  Return a string if the target property expects a string.
  Return a number if the target property expects a number.
  Return an object if the target property expects an object.

  `HeroDetail` 컴포넌트의 `hero` 프로퍼티는 `Hero` 객체를 기대합니다. 이것이 정확히 프로퍼티 바인딩에서 보내는 것입니다:

  The `hero` property of the `HeroDetail` component expects a `Hero` object, which is exactly what you're sending in the property binding:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-4')(format=".")

block dart-type-exceptions
  //- N/A

:marked
  ### 대괄호를 기억하세요
  ### Remember the brackets

  대괄호는 Angular에게 템플릿 표현식을 평가하라고 알려줍니다.
  만약 대괄호를 빼먹으면, Angular는 문자열을 상수로 다루고 
  그 문자열로 *타깃 프로퍼티를 초기화*합니다.
  문자열을 평가하지 *않습니다*!

  The brackets tell Angular to evaluate the template expression.
  If you omit the brackets, Angular treats the string as a constant and *initializes the target property* with that string.
  It does *not* evaluate the string!

  다음과 같은 실수를 저지르지 마세요:

  Don't make the following mistake:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-6')(format=".")

block dart-type-exception-example
  //- N/A

a(id="one-time-initialization")
:marked
  ### 일회성 문자열 초기화
  ### One-time string initialization
  다음이 모두 참인 경우 대괄호를 제거 *해야만* 합니다:

  You *should* omit the brackets when all of the following are true:

  * 타깃 프로퍼티가 문자열 값을 받음.

  * The target property accepts a string value.

  * 문자열이 템플릿 안에서 처리 가능한 고정된 값임.

  * The string is a fixed value that you can bake into the template.

  * 초기 값이 절대 변경되지 않음.

  * This initial value never changes.

  일반적으로 표준 HTML에서는 이런 방법으로 속성을 초기화합니다.
  또한 지시자나 컴포넌트 초기화에서는 잘 작동합니다.
  다음 예제는 `HeroDetailComponent`의 `prefix` 속성을 템플릿 표현식이 아닌 고정된 문자열로 초기화 합니다.
  Angular는 그것을 셋팅하고 잊어버립니다.

  You routinely initialize attributes this way in standard HTML, and it works
  just as well for directive and component property initialization.
  The following example initializes the `prefix` property of the `HeroDetailComponent` to a fixed string,
  not a template expression. Angular sets it and forgets about it.
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-7')(format=".")
:marked
  반면에 `[hero]` 바인딩은 컴포넌트의 `currentHero` 프로퍼티에 유효한 바인딩으로 남아있습니다.

  The `[hero]` binding, on the other hand, remains a live binding to the component's `currentHero` property.

  ### 프로퍼티 바인딩? 삽입식?
  ### Property binding or interpolation?
  종종 삽입식과 프로퍼티 바인딩 사이에서 선택을 해야 합니다.
  다음 바인딩 쌍은 같은 역할을 합니다:

  You often have a choice between interpolation and property binding. 
  The following binding pairs do the same thing:
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-vs-interpolation')(format=".")
:marked
  _삽입식_은 많은 경우에 _프로퍼티 바인딩_의 편리한 대안입니다.

  _Interpolation_ is a convenient alternative to _property binding_ in many cases.

  데이터 값을 문자열로 렌더링 할 때, 하나의 방식을 선호할 기술적인 이유는 없습니다.
  우리는 가독성 때문에 삽입식을 선호하는 경향이 있습니다.
  코딩 스타일 규칙을 정하고 현재 실무에 가장 자연스러운 느낌을 주는
  방식으로 선택하는 것이 좋습니다.

  When rendering data values as strings, there is no technical reason to prefer one form to the other.
  You lean toward readability, which tends to favor interpolation.
  You suggest establishing coding style rules and choosing the form that
  both conforms to the rules and feels most natural for the task at hand.

  엘리먼트 프로퍼티를 문자열이 아닌 데이터 값에 셋팅할 때는 반드시 _프로퍼티 바인딩_을 사용해야 합니다.

  When setting an element property to a non-string data value, you must use _property binding_.

:marked
  #### 컨텐츠 보안
  #### Content security
  다음과 같은 *악성 컨텐츠*를 가정해보겠습니다.

  Imagine the following *malicious content*.
+makeExample('template-syntax/ts/src/app/app.component.ts', 'evil-title')(format=".")    
:marked
  다행히도, Angular 데이터 바인딩은 위험한 HTML에 대해 경고해줍니다.
  그것들을 표시하기 전에 값을 *정제*합니다.
  삽입식이나 프로퍼티 바인딩에서 스크립트 태그를 가진 HTML이 
  브라우저에 노출되지 *않도록* 합니다.

  Fortunately, Angular data binding is on alert for dangerous HTML.
  It *sanitizes* the values before displaying them.
  It **will not** allow HTML with script tags to leak into the browser, neither with interpolation
  nor property binding.
+makeExample('template-syntax/ts/src/app/app.component.html', 'property-binding-vs-interpolation-sanitization')(format=".")    
:marked
  삽입식은 스크립트 태그를 프로퍼티 바인딩과 다르게 다룹니다. 
  그러나 두가지 방법 모두 컨텐츠를 무해하게 렌더링합니다.

  Interpolation handles the script tags differently than property binding but both approaches render the
  content harmlessly.
figure.image-display
  img(src='/resources/images/devguide/template-syntax/evil-title.png' alt="evil title made safe" width='500px')

:marked
  &nbsp;
a(href="#toc") back to top

.l-hr
a#other-bindings
:marked
  ## 속성, 클래스, 스타일 바인딩
  ## Attribute, class, and style bindings
  템플릿 구문은 프로퍼티 바인딩이 적합하지 않은 시나리오를 위해 특화된 단방향 바인딩을 제공합니다.

  The template syntax provides specialized one-way bindings for scenarios less well suited to property binding.

  ### 속성 바인딩
  ### Attribute binding

  **속성 바인딩**으로 직접 속성의 값을 설정할 수 있습니다.

  You can set the value of an attribute directly with an **attribute binding**.

.l-sub-section
  :marked
    이것은 바인딩이 타깃 프로퍼티를 셋팅한다는 규칙에 대한 유일한 예외사항입니다. 이것은 속성을 생성하고 설정하는 유일한 바인딩입니다.

    This is the only exception to the rule that a binding sets a target property. This is the only binding that creates and sets an attribute.

:marked
  이번 챕터에서는 프로퍼티 바인딩으로 엘리먼트 프로퍼티를 설정하는 것이 문자열로 속성을 설정하는 것보다 항상 좋다고 강조했습니다. Angular는 왜 속성 바인딩을 제공할까요?

  This guide stresses repeatedly that setting an element property with a property binding is always preferred to setting the attribute with a string. Why does Angular offer attribute binding?

  **바인딩 할 엘리먼트 프로퍼티가 없을 경우에는 반드시 속성 바인딩을 사용해야 합니다.**

  **You must use attribute binding when there is no element property to bind.**

  [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA),
  [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG), 그리고
  테이블 span 속성을 생각해보세요. 이것들은 순수한 속성입니다.
  엘리먼트 프로퍼티에 해당하지는 않으며, 이것들은 엘리먼트 프로퍼티를 설정하지 않습니다.
  이것들은 바인딩할 프로퍼티 타깃이 없습니다.  

  Consider the [ARIA](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA),
  [SVG](https://developer.mozilla.org/en-US/docs/Web/SVG), and
  table span attributes. They are pure attributes.
  They do not correspond to element properties, and they do not set element properties.
  There are no property targets to bind to.

  이 사실은 이와 비슷한 것을 쓸 때 매우 명백해집니다.

  This fact becomes painfully obvious when you write something like this.

code-example(language="html").
  &lt;tr&gt;&lt;td colspan="{{1 + 1}}"&gt;Three-Four&lt;/td&gt;&lt;/tr&gt;
:marked
  그리고 이런 에러가 발생합니다:

  And you get this error:

code-example(format="nocode").
  Template parse errors:
  Can't bind to 'colspan' since it isn't a known native property
:marked
  메시지는 `<td>` 엘리먼트가 `colspan` 프로퍼티를 가지고 있지 않다고 말하고 있습니다.
  "colspan" *속성*은 가지고 있지만, 삽입식과 프로퍼티 바인딩은 속성이 아닌 오직
  *프로퍼티*만 설정할 수 있습니다.
  
  As the message says, the `<td>` element does not have a `colspan` property.
  It has the "colspan" *attribute*, but
  interpolation and property binding can set only *properties*, not attributes.

  이러한 속성을 생성하고 바인딩하려면 속성 바인딩이 필요합니다.

  You need attribute bindings to create and bind to such attributes.

  속성 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  대괄호 사이의 엘리먼트 프로퍼티 대신에, **`attr`**로 시작하고,
  점(`.`)과 속성의 이름을 붙입니다. 
  그 다음 문자열을 나타내는 표현식을 사용해 속성값을 설정합니다.

  Attribute binding syntax resembles property binding.
  Instead of an element property between brackets, start with the prefix **`attr`**,
  followed by a dot (`.`) and the name of the attribute. 
  You then set the attribute value, using an expression that resolves to a string.

  `[attr.colspan]`을 계산된 값에 바인딩했습니다:

  Bind `[attr.colspan]` to a calculated value:
+makeExample('template-syntax/ts/src/app/app.component.html', 'attrib-binding-colspan')(format=".")

:marked
  다음은 테이블을 렌더링하는 방법입니다:

  Here's how the table renders:
  <table border="1px">
    <tr><td colspan="2">One-Two</td></tr>
    <tr><td>Five</td><td>Six</td></tr>
   </table>

  속성 바인딩의 주요 사례 중 하나는 
  다음 예처럼 ARIA 속성을 설정하는 것입니다:  

  One of the primary use cases for attribute binding
  is to set ARIA attributes, as in this example:
+makeExample('template-syntax/ts/src/app/app.component.html', 'attrib-binding-aria')(format=".")

a(href="#toc") back to top

.l-hr
:marked
  ### 클래스 바인딩
  ### Class binding

  **클래스 바인딩**으로 엘리먼트의 `class` 속성에서 
  CSS 클래스 이름을 추가하거나 제거할 수 있습니다.

  You can add and remove CSS class names from an element's `class` attribute with
  a **class binding**.

  클래스 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  괄호 사이의 엘리먼트 프로퍼티 대신에, `class`로 시작하고,
  선택적으로 점 (`.`)과 CSS 클래스 이름을 붙입니다: `[class.class-name]`.

  Class binding syntax resembles property binding.
  Instead of an element property between brackets, start with the prefix `class`,
  optionally followed by a dot (`.`) and the name of a CSS class: `[class.class-name]`.

  다음 예제는 클래스 바인딩으로 애플리케이션의 "special" 클래스를 추가하고 제거하는 방법을
  보여줍니다. 바인딩을 사용하지 않고 속성을 설정하는 방법은 다음과 같습니다:

  The following examples show how to add and remove the application's "special" class
  with class bindings.  Here's how to set the attribute without binding:
+makeExample('template-syntax/ts/src/app/app.component.html', 'class-binding-1')(format=".")
:marked
  이것을 원하는 클래스 이름의 문자열에 바인딩할 수도 있습니다; 이렇게 하면 전부 바인딩 되거나 아무것도 바인딩 되지 않습니다.

  You can replace that with a binding to a string of the desired class names; this is an all-or-nothing, replacement binding.
+makeExample('template-syntax/ts/src/app/app.component.html', 'class-binding-2')(format=".")

:marked
  마지막으로 특별한 클래스 이름에 바인딩할 수 있습니다.
  Angular는 템플릿 표현식이 #{_truthy_ko}으로 평가될 때 클래스를 더합니다.
  표현식이 #{_falsey_ko}인 경우 클래스를 제거합니다.

  Finally, you can bind to a specific class name.
  Angular adds the class when the template expression evaluates to #{_truthy}.
  It removes the class when the expression is #{_falsy}.
+makeExample('template-syntax/ts/src/app/app.component.html', 'class-binding-3')(format=".")

.l-sub-section
  :marked
    비록 이것이 단일 클래스 이름을 토글하는 좋은 방법이지만,
    여러 클래스 이름을 동시에 관리하기 위해서는 일반적으로 [NgClass 지시자](#ngClass)를 선호합니다.

    While this is a fine way to toggle a single class name,
    the [NgClass directive](#ngClass) is usually preferred when managing multiple class names at the same time.

a(href="#toc") back to top

.l-hr
:marked
  ### 스타일 바인딩
  ### Style binding

  **스타일 바인딩**으로 인라인 스타일을 설정할 수 있습니다.

  You can set inline styles with a **style binding**.

  스타일 바인딩 구문은 프로퍼티 바인딩과 비슷합니다.
  대괄호 사이에 엘리먼트 프로퍼티 대신에, `style`로 시작하고,
  점 (`.`)과 CSS 스타일 프로퍼티의 이름을 붙입니다: `[style.style-property]`.

  Style binding syntax resembles property binding.
  Instead of an element property between brackets, start with the prefix `style`,
  followed by a dot (`.`) and the name of a CSS style property: `[style.style-property]`.

+makeExample('template-syntax/ts/src/app/app.component.html', 'style-binding-1')(format=".")
:marked
  어떤 스타일 바인딩의 스타일은 단위 확장자가 있습니다. 
  다음의 예에서는 조건에 따라 글꼴 크기를 “em” 및 “%”로 설정합니다.

  Some style binding styles have a unit extension. 
  The following example conditionally sets the font size in  “em” and “%” units .
+makeExample('template-syntax/ts/src/app/app.component.html', 'style-binding-2')(format=".")

.l-sub-section
  :marked
    비록 이것인 단일 스타일에는 좋은 방법이지만,
    여러 인라인 스타일을 동시에 설정할 때는 일반적으로 [NgStyle 지시자](#ngStyle)를 선호합니다.

    While this is a fine way to set a single style,
    the [NgStyle directive](#ngStyle) is generally preferred when setting several inline styles at the same time.

.l-sub-section
  :marked
    _스타일 프로퍼티_ 이름은 
    위에서 본 것처럼 [dash-case](glossary.html#dash-case)으로 쓰여지거나,
    `fontSize`처럼 [camelCase](glossary.html#camelcase)로 쓰여질 수 있습니다.

    Note that a _style property_ name can be written in either
    [dash-case](glossary.html#dash-case), as shown above, or
    [camelCase](glossary.html#camelcase), such as `fontSize`.

block style-property-name-dart-diff
  //- N/A

a(href="#toc") back to top

.l-hr
a#event-binding
:marked
  ## 이벤트 바인딩  ( <span class="syntax">(event)</span> )
  ## Event binding  ( <span class="syntax">(event)</span> )
  
  지금껏 살펴본 바인딩은 데이터가 한 방향으로 흘렀습니다: **컴포넌트에서 엘리먼트로**.

  The bindings directives you've met so far flow data in one direction: **from a component to an element**.

  사용자가 화면을 응시만 하는 것은 아닙니다. 그들은 입력 상자에 텍스트를 입력합니다. 그들은 리스트에서 아이템을 선택합니다.
  그들은 버튼을 클릭합니다. 이러한 사용자 액션은 데이터가 반대편 방향으로 흐르게 합니다:
  **엘리먼트에서 컴포넌트로**.

  Users don't just stare at the screen. They enter text into input boxes. They pick items from lists.
  They click buttons. Such user actions may result in a flow of data in the opposite direction:
  **from an element to a component**.

  사용자 액션을 알 수 있는 유일한 방법은 키입력, 마우스 움직임, 클릭, 터치와 같은 
  특정 이벤트를 듣는 것입니다.
  Angular 이벤트 바인딩을 통해 사용자 액션 중 관심있는 것을 선언합니다.

  The only way to know about a user action is to listen for certain events such as
  keystrokes, mouse movements, clicks, and touches.
  You declare your interest in user actions through Angular event binding.

  이벤트 바인딩 문법은 등호의 왼쪽에 소괄호로 둘러싸인 **타깃 이벤트**와 
  등호의 오른쪽에 따옴표로 둘러싸인 [템플릿 명령문](#template-statements)으로 구성됩니다.
  다음 이벤트 바인딩은 버튼의 클릭 이벤트를 듣고,
  클릭이 발생할 때마다 컴포넌트의 `onSave()` 메소드를 호출합니다:

  Event binding syntax consists of a **target event** within parentheses on the left of an equal sign, and a quoted
  [template statement](#template-statements) on the right.
  The following event binding listens for the button's click event, calling
  the component's `onSave()` method whenever a click occurs:
+makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-1')(format=".")
:marked
  ### 타깃 이벤트
  ### Target event
  **소괄호 사이의 이름**은 &mdash; 예를 들어, `(click)` &mdash;
  타깃 이벤트를 식별합니다. 다음 예제에서, 타깃은 버튼의 클릭 이벤트 입니다.

  A **name between parentheses** &mdash; for example, `(click)` &mdash;
  identifies the target event. In the following example, the target is the button's click event.
+makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-1')(format=".")
:marked
  어떤 사람들은 **정규형**으로 알려진 `on-` 접두어 방식을 선호합니다.

  Some people prefer the `on-` prefix alternative, known as the **canonical form**:
+makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-2')(format=".")
:marked
  엘리먼트 이벤트는 보다 일반적인 타깃일 것입니다, 그러나 Angular는 알려진 지시자의 이벤트 프로퍼티인지
  먼저 확인합니다. 다음 예제에서 처리하는 방식입니다:

  Element events may be the more common targets, but Angular looks first to see if the name matches an event property
  of a known directive, as it does in the following example:
+makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-3')(format=".")

.l-sub-section
  :marked
    `myClick` 지사자는 [인풋/아웃풋 프로퍼티에 별칭 붙이기](#aliasing-io)
    에서 보다 자세히 설명하겠습니다.

    The `myClick` directive is further described in the section
    on [aliasing input/output properties](#aliasing-io).

:marked
  그 이름과 같은 엘리먼트 이벤트 또는 알려진 지시자의 아웃풋 프로퍼티를 찾지 못했다면,
  Angular는 “unknown directive” 에러를 보고합니다.

  If the name fails to match an element event or an output property of a known directive,
  Angular reports an “unknown directive” error.

  ### *$event* 와 이벤트 핸들링 명령문
  ### *$event* and event handling statements

  이벤트 바인딩에서, Angular는 타깃 이벤트에 이벤트 핸들러를 설정합니다.

  In an event binding, Angular sets up an event handler for the target event.

  이벤트가 발생하면, 핸들러는 템플릿 명령문을 실행합니다.
  템플릿 명령문은 전형적으로 수신자를 포함합니다.
  수신자는 그 이벤트에 대해 HTML 컨트롤의 값을 모델에 저장하는 것과 같은 
  액션을 수행합니다.

  When the event is raised, the handler executes the template statement.
  The template statement typically involves a receiver, which performs an action
  in response to the event, such as storing a value from the HTML control
  into a model.

  바인딩은 **`$event`라는 이벤트 객체**를 통해
  데이터 값을 포함한 이벤트에 대한 정보를 전달합니다.

  The binding conveys information about the event, including data values, through
  an **event object named `$event`**.

  이벤트 객체의 모양은 타깃 이벤트에 의해 결정됩니다.
  만약 타깃 이벤트가 네이티브 DOM 엘리먼트 이벤트라면, `$event`는
  `target` 및 `target.value`와 같은 속성을 가진
  [DOM 이벤트 객체]( https://developer.mozilla.org/en-US/docs/Web/Events)입니다.

  The shape of the event object is determined by the target event.
  If the target event is a native DOM element event, then `$event` is a
  [DOM event object]( https://developer.mozilla.org/en-US/docs/Web/Events),
  with properties such as `target` and `target.value`.

  다음 예제를 보겠습니다:

  Consider this example:
+makeExample('template-syntax/ts/src/app/app.component.html', 'without-NgModel')(format=".")

:marked
  이 코드는 `firstName` 프로퍼티 값을 `value` 프로퍼티에 바인딩합니다. 값의 변경을 감지하기 위해, 입력 상자의 `input` 이벤트에 바인딩합니다.
  사용자가 변화를 일으키면, `input` 이벤트가 발생하고, 바인딩은 `$event` DOM 이벤트 객체를 포함하는 객체 안에서 명령문을 실행합니다.

  This code sets the input box `value` property by binding to the `name` property. To listen for changes to the value, the code binds to the input box's `input` event.
  When the user makes changes, the `input` event is raised, and the binding executes the statement within a context that includes the DOM event object, `$event`.

  `firstName` 프로퍼티를 업데이트 하기 위해 `$event.target.value` 경로를 따라 변경 텍스트를 가져옵니다.

  To update the `name` property, the changed text is retrieved by following the path `$event.target.value`.

  만약 이벤트가 지시자에 속한다면 (컴포넌트는 지시자였던 것을 기억하세요), `$event`는 지시자가 생성하기로 결정한 어떤 형태가 됩니다.

  If the event belongs to a directive (recall that components are directives), `$event` has whatever shape the directive decides to produce.

a#eventemitter
a#custom-event
:marked
  ### <span class="syntax">EventEmitter</span>를 사용한 커스텀 이벤트
  ### Custom events with <span class="syntax">EventEmitter</span>

  지시자는 일반적으로 Angular [EventEmitter](../api/core/index/EventEmitter-class.html)
  를 사용해 커스텀 이벤트를 발생시킵니다.
  지시자는 `EventEmitter`를 생성하고 그것을 프로퍼티로 노출합니다.
  지시자는 이벤트를 발생시키기 위해 `EventEmitter.emit(payload)`를 호출합니다.
  메시지 payload로 전달되는 것은 어떤 것이든 될 수 있습니다.
  부모 지시자는 해당 프로퍼티에 바인딩하여 이벤트를 들을 수 있고
  `$event` 객체를 통해 payload에 접근할 수 있습니다.

  Directives typically raise custom events with an Angular [EventEmitter](../api/core/index/EventEmitter-class.html).
  The directive creates an `EventEmitter` and exposes it as a property.
  The directive calls `EventEmitter.emit(payload)` to fire an event, passing in a message payload, which can be anything.
  Parent directives listen for the event by binding to this property and accessing the payload through the `$event` object.

  히어로 정보를 표현하고 사용자 액션에 반응하는 `HeroDetailComponent`를 생각해보겠습니다.
  비록 `HeroDetailComponent`가 삭제 버튼을 가지고 있지만, 히어로 자신을 어떻게 지우는지 모르고 있습니다.
  그렇게 하는 최선의 방법은 사용자의 삭제 요청을 보고하는 이벤트를 발생시키는 것입니다.

  Consider a `HeroDetailComponent` that presents hero information and responds to user actions.
  Although the `HeroDetailComponent` has a delete button it doesn't know how to delete the hero itself.
  The best it can do is raise an event reporting the user's delete request.

  다음은 `HeroDetailComponent`에서 적절히 발췌한 부분입니다:

  Here are the pertinent excerpts from that `HeroDetailComponent`:
+makeExcerpt('src/app/hero-detail.component.ts (template)', 'template-1')
+makeExcerpt('src/app/hero-detail.component.ts', 'deleteRequest')

:marked
  컴포넌트는 `EventEmitter`를 반환하는 `deleteRequest` 프로퍼티를 정의합니다.
  사용자가 *삭제*를 클릭하면, 컴포넌트는 `EventEmitter`가 `Hero` 객체를 노출하라고 말하는
  `delete()` 메소드를 호출합니다.

  The component defines a `deleteRequest` property that returns an `EventEmitter`.
  When the user clicks *delete*, the component invokes the `delete()` method, 
  telling the `EventEmitter` to emit a `Hero` object.

  이제 `HeroDetailComponent`의 `deleteRequest` 이벤트에 바인딩하는 부모 컴포넌트를 상상해보세요.

  Now imagine a hosting parent component that binds to the `HeroDetailComponent`'s `deleteRequest` event.

+makeExcerpt('src/app/app.component.html', 'event-binding-to-component', '')

:marked
  `deleteRequest` 이벤트가 발생하면, Angular는 부모 컴포넌트의 `deleteHero` 메소드를 호출합니다.
  메소드는 `$event` 변수 안에 (`HeroDetail`이 방출하는) *삭제하려는 히어로*를 전달합니다.

  When the `deleteRequest` event fires, Angular calls the parent component's `deleteHero` method,
  passing the *hero-to-delete* (emitted by `HeroDetail`) in the `$event` variable.

  ### 템플릿 명령문의 부작용
  ### Template statements have side effects

  `deleteHero` 메소드는 부작용이 있습니다: 히어로를 삭제하는 것입니다.
  템플릿 명령문의 부작용은 단순한 문제가 아닙니다. 그러나 예상할 수 있습니다.

  The `deleteHero` method has a side effect: it deletes a hero.
  Template statement side effects are not just OK, but expected.

  히어로 삭제는 모델을 업데이트합니다. 
  아마 원격 서버에 조회하고 저장하는 것을 포함해 다른 변경사항을 유발할 것입니다.
  이러한 변경사항은 시스템을 통해 퍼지고 궁극적으로 이 화면 또는 다른 화면에 표시될 것입니다.

  Deleting the hero updates the model, perhaps triggering other changes
  including queries and saves to a remote server.
  These changes percolate through the system and are ultimately displayed in this and other views.

//-
  :marked
    ### Event bubbling and propagation [TODO: reinstate this section when it becomes true]
    Angular invokes the event-handling statement if the event is raised by the current element or one of its child elements.
  +makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-bubbling')(format=".")
  :marked
    Many DOM events, both [native](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Overview_of_Events_and_Handlers ) and [custom](https://developer.mozilla.org/en-US/docs/Web/Guide/Events/Creating_and_triggering_events ), bubble up their ancestor tree of DOM elements until an event handler along the way prevents further propagation.

  .l-sub-section
    :marked
      `EventEmitter` events don't bubble.

  :marked
    The result of an event binding statement determines whether
    [event propagation](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Examples#Example_5:_Event_Propagation)
    continues or stops with the current element.

    Event propagation stops if the binding statement returns a falsy value (as does a method with no return value).
    Clicking the button in the next example triggers a save;
    the click doesn't make it to the outer `<div>` so the div's save handler is not called.
  +makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-no-propagation')(format=".")
  :marked
    Propagation continues if the statement returns a truthy value. In the next example, the click is heard by both the button
    and the outer `<div>`, causing a double save.
  +makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-propagation')(format=".")

a(href="#toc") back to top

.l-hr
a#two-way
:marked
  ## 양방향 바인딩 ( <span class="syntax">[(...)]</span> )
  ## Two-way binding ( <span class="syntax">[(...)]</span> )

  우리는 종종 데이터 프로퍼티를 표시하고 사용자가 변경을 하면 그 프로퍼티를 업데이트하고 싶어 합니다.

  You often want to both display a data property and update that property when the user makes changes.

  엘리먼트 측면에서보면 특정 엘리먼트 프로퍼티로 설정하는 것과
  엘리먼트의 변경 이벤트를 듣는 것을 조합해야 합니다.

  On the element side that takes a combination of setting a specific element property
  and listening for an element change event.

  Angular는 이러한 목적을 위해 특별한 _양방향 데이터 바인딩_ 구문, **`[(x)]`** 을 제공합니다.
  `[(x)]` 구문은 프로퍼티 바인딩의 대괄호 `[x]`와 
  _이벤트 바인딩_의 소괄호 `(x)`를 조합한 것입니다.

  Angular offers a special _two-way data binding_ syntax for this purpose, **`[(x)]`**.
  The `[(x)]` syntax combines the brackets 
  of _property binding_, `[x]`, with the parentheses of _event binding_, `(x)`.

.callout.is-important
  header [( )] = 상자 안의 바나나
  header [( )] = banana in a box
  :marked
    *상자 안의 바나나*를 연상하여 대괄호 안에 들어가는 소괄호를 기억하세요.

    Visualize a *banana in a box* to remember that the parentheses go _inside_ the brackets.

:marked
  `[(x)]` 구문은 엘리먼트가 `x`라는 세터 프로퍼티를 가지고
  `xChange`라는 이벤트를 가진 경우로 쉽게 설명할 수 있습니다.
  여기에 패턴에 맞는 `SizerComponent`가 있습니다.
  `size` 값 프로퍼티와 `sizeChange` 이벤트를 동반하고 있습니다.

  The `[(x)]` syntax is easy to demonstrate when the element has a settable property called `x`
  and a corresponding event named `xChange`. 
  Here's a `SizerComponent` that fits the pattern.
  It has a `size` value property and a companion `sizeChange` event:

+makeExample('src/app/sizer.component.ts')

:marked
  초기 `size`는 프로퍼티 바인딩의 입력값 입니다.
  버튼을 클릭하면 min/max 값 제약 안에서 `size`가 증감하고,
  크기를 조절하면 `sizeChange` 이벤트를 발생시킵니다. (_방출합니다._)

  The initial `size` is an input value from a property binding.
  Clicking the buttons increases or decreases the `size`, within min/max values constraints,
  and then raises (_emits_) the `sizeChange` event with the adjusted size.

  다음은 `AppComponent.fontSizePx`가 `SizerComponent`에 양방향 바인딩을 하는 예제입니다:

  Here's an example in which the `AppComponent.fontSizePx` is two-way bound to the `SizerComponent`:

+makeExcerpt('src/app/app.component.html', 'two-way-1', '')

:marked
  `AppComponent.fontSizePx`는 초기 `SizerComponent.size` 값을 설정합니다.
  버튼 클릭은 양방향 바인딩으로 `AppComponent.fontSizePx`를 업데이트 합니다.
  수정된 `AppComponent.fontSizePx` 값은 표시 텍스트를 크게하거나 작게하는 _스타일_ 바인딩으로 흐릅니다. 
  <live-example></live-example>에서 시도해보세요.

  The `AppComponent.fontSizePx` establishes the initial `SizerComponent.size` value.
  Clicking the buttons updates the `AppComponent.fontSizePx` via the two-way binding.
  The revised `AppComponent.fontSizePx` value flows through to the _style_ binding, making the displayed text bigger or smaller.
  Try it in the <live-example></live-example>.

  양방향 바인딩 구문은 정말로 그저 _프로퍼티_ 바인딩과 _이벤트_ 바인딩을 위한 간편 표기법(syntactic sugar)입니다.
  Angular는 `SizerComponent` 바인딩을 다음과 같이 번역합니다.

  The two-way binding syntax is really just syntactic sugar for a _property_ binding and an _event_ binding.
  Angular _desugars_ the `SizerComponent` binding into this:

+makeExcerpt('src/app/app.component.html', 'two-way-2', '')

:marked
  `$event` 변수는 `SizerComponent.sizeChange` 이벤트의 payload를 담고 있습니다.
  Angular는 사용자가 버튼을 클릭하면 `$event` 값을 `AppComponent.fontSizePx`에 할당합니다.

  The `$event` variable contains the payload of the `SizerComponent.sizeChange` event.
  Angular assigns the `$event` value to the `AppComponent.fontSizePx` when the user clicks the buttons.

  분명히 양방향 바인딩 구문은 프로퍼티와 이벤트 바인딩을 분리하는 것에 비해 매우 편리합니다.

  Clearly the two-way binding syntax is a great convenience compared to separate property and event bindings.

  `<input>`과 `<select>` 같은 HTML 폼 엘리먼트에 양방향 바인딩을 사용하는 것은 편리합니다.
  하지만 어떠한 네이티브 HTML 엘리먼트도 `x` 값과 `xChange` 이벤트 패턴을 따르지 않습니다.

  It would be convenient to use two-way binding with HTML form elements like `<input>` and `<select>`.
  However, no native HTML element follows the `x` value and `xChange` event pattern.

  다행히도 Angular [_NgModel_](#ngModel) 지시자는 폼 엘리먼트가 양방향 바인딩을 가능하게 하는 가교 역할을 합니다.

  Fortunately, the Angular [_NgModel_](#ngModel) directive is a bridge that enables two-way binding to form elements.

a(href="#toc") back to top

.l-hr
a#directives
:marked
  ## 내장 지시자
  ## Built-in directives

  Angular의 초기 버전은 70개 이상의 내장 지시자가 포함되어 있었습니다.
  커뮤니티는 더 많은 기여를 했으며, 내부 애플리케이션에 사용되는
  무수히 많은 private 지시자가 생성되었습니다.

  Earlier versions of Angular included over seventy built-in directives.
  The community contributed many more, and countless private directives
  have been created for internal applications.

  Angular 개발에 이러한 지시자가 많이 필요하지는 않습니다.
  상당 부분은 보다 기능적이고 표현력 있는 Angular 바인딩 시스템으로 동일한 결과를 얻을 수 있습니다.
  왜 다음과 같은 간단한 바인딩을 작성할 때 클릭 처리 지시자를 만들까요?

  You don't need many of those directives in Angular.
  You can often achieve the same results with the more capable and expressive Angular binding system.
  Why create a directive to handle a click when you can write a simple binding such as this?
+makeExample('template-syntax/ts/src/app/app.component.html', 'event-binding-1')(format=".")
:marked
  복잡한 작업을 간략화하는 지시자로부터 혜택을 볼 수 있습니다.
  Angular는 그렇게 많지는 않지만 여전히 내장 지시자를 배포하고 있습니다.
  우리 자신만의 지시자를 몇개 만들어 보겠습니다.

  You still benefit from directives that simplify complex tasks.
  Angular still ships with built-in directives; just not as many.
  You'll write your own directives, just not as many.

  이 세그먼트에는 [_속성_ 지시자(attribute directives)](#attribute-directives)또는 [_구조_ 지시자(structural directives)](#structural-directives)로 분류되는 가장 많이 사용되는 내장 지시자를 살펴보겠습니다.

  This segment reviews some of the most frequently used built-in directives,
  classified as either [_attribute_ directives](#attribute-directives) or [_structural_ directives](#structural-directives).

.l-hr
a#attribute-directives
:marked
  ## 내장 _속성_ 지시자
  ## Built-in _attribute_ directives

  속성 지시자는 다른 HTML 요소, 속성, 프로퍼티 및 컴포넌트의 동작을 수신하고 수정합니다.
  일반적으로 HTML 속성 인 것처럼 요소에 적용되므로, 이름이 적용됩니다.

  Attribute directives listen to and modify the behavior of
  other HTML elements, attributes, properties, and components. 
  They are usually applied to elements as if they were HTML attributes, hence the name.

  많은 세부 사항은 [_Attribute Directives_](attribute-directives.html) 가이드에서 다룹니다.
  [`RouterModule`](router.html "Routing and Navigation")과 [`FormsModule`](forms.html "Forms")과 같은 Angular 모듈에는 고유 한 속성 지시자가 있습니다.
  이 섹션은 가장 일반적으로 사용되는 속성 지시자에 대한 소개입니다: 

  Many details are covered in the [_Attribute Directives_](attribute-directives.html) guide.
  Many Angular modules such the [`RouterModule`](router.html "Routing and Navigation") 
  and the [`FormsModule`](forms.html "Forms") have their own attribute directives.
  This section is an introduction to the most commonly used attribute directives:

  * [`NgClass`](#ngClass) - CSS 클래스 집합 추가 및 제거

  * [`NgClass`](#ngClass) - add and remove a set of CSS classes

  * [`NgStyle`](#ngStyle) - HTML 스타일 집합 추가 및 제거

  * [`NgStyle`](#ngStyle) - add and remove a set of HTML styles

  * [`NgModel`](#ngModel) - HTML 폼 요소에 양방향 데이터 바인딩

  * [`NgModel`](#ngModel) - two-way data binding to an HTML form element

a(href="#toc") back to top

.l-hr
a#ngClass
:marked
  ### NgClass
  ### NgClass

  우리는 일반적으로 CSS 클래스를 동적으로 추가하거나 제거하여
  엘리먼트가 보이는 것을 제어합니다.
  `NgClass`에 바인딩하여 동시에 여러 클래스를 추가하거나 제거할 수 있습니다.

  You typically control how elements appear
  by adding and removing CSS classes dynamically.
  You can bind to the `ngClass` to add or remove several classes simultaneously.

  [클래스 바인딩](#class-binding)은 *단일* 클래스를 추가하거나 제거하기 위해 좋은 방법입니다.

  A [class binding](#class-binding) is a good way to add or remove a *single* class.
+makeExample('template-syntax/ts/src/app/app.component.html', 'class-binding-3a')(format=".")
:marked
  *많은* CSS 클래스를 동시에 추가하거나 제거하기 위해, `NgClass` 지시자가 좀 더 좋은 선택입니다.

  To add or remove *many* CSS classes at the same time, the `NgClass` directive may be the better choice.

  key:value 제어 !{__objectAsMap_ko}에 `NgClass`를 바인딩하세요.
  각 객체의 키는 CSS 클래스 이름입니다; 그것의 값은 클래스가 추가되어야 할 경우 `true`,
  제거되어야 할 경우 `false`가 됩니다.

  Try binding `ngClass` to a key:value control !{__objectAsMap}. 
  Each key of the object is a CSS class name; its value is `true` if the class should be added, 
  `false` if it should be removed.

:marked
  컴포넌트 프로퍼티 `currentClasses` 객체를 설정하는 컴포넌트 메소드 `setCurrentClasses`를 생각해보겠습니다.
  이것은 3개의 다른 컴포넌트 프로퍼티의 `true`/`false` 상태에 따라
  3개의 클래스를 추가하거나 제거합니다.

  Consider a `setCurrentClasses` component method that sets a component property, 
  `currentClasses` with an object that adds or removes three classes based on the 
  `true`/`false` state of three other component properties:
+makeExample('template-syntax/ts/src/app/app.component.ts', 'setClasses')(format=".")
:marked
  다음과 같이 `NgClass` 프로퍼티 바인딩을 추가하여 `currentClasses`가 엘리먼트의 클래스를 설정하도록 하세요:

  Adding an `ngClass` property binding to `currentClasses` sets the element's classes accordingly:  
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgClass-1')(format=".")
.l-sub-section
  :marked
    종속되는 프로퍼티가 변경되거나 초기화 할 때, `setCurrentClasses()`를 호출하는 것은 여러분에게 달려있습니다.

    It's up to you to call `setCurrentClassess()`, both initially and when the dependent properties change.

a(href="#toc") back to top

.l-hr
a#ngStyle
:marked
  ### NgStyle
  ### NgStyle
  컴포넌트의 상태에 따라 동적으로 인라인 스타일을 설정할 수 있습니다.
  `NgStyle`에 바인딩하여 많은 인라인 스타일을 동시에 설정할 수 있습니다.

  You can set inline styles dynamically, based on the state of the component.
  With `NgStyle` you can set many inline styles simultaneously.

  [스타일 바인딩](#style-binding)은 *단일* 스타일 값을 설정하는 간단한 방법입니다.

  A [style binding](#style-binding) is an easy way to set a *single* style value.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgStyle-1')(format=".")
:marked
  *많은* CSS 인라인 스타일을 동시에 추가하거나 제거하려면, `NgStyle` 지시자가 좀 더 좋은 선택입니다.

  To set *many* inline styles at the same time, the `NgStyle` directive may be the better choice.

  key:value 제어 !{__objectAsMap_ko}에 `NgStyle`을 바인딩하세요.
  각 객체의 키는 스타일 이름입니다; 그것의 값은 해당 스타일에 적합한 어떤 것입니다.

  Try binding `ngStyle` to a key:value control !{__objectAsMap}.
  Each key of the object is a style name; its value is whatever is appropriate for that style.

  컴포넌트 프로퍼티 `currentStyles` 객체를 설정하는 컴포넌트 메소드 `setCurrentStyles`를 생각해보겠습니다.
  이것은 3개의 다른 컴포넌트 프로퍼티의 상태에 따라 3개의 스타일을 추가하거나 제거합니다.

  Consider a `setCurrentStyles` component method that sets a component property, `currentStyles`
  with an object that defines three styles, based on the state of three other component propertes:
+makeExample('template-syntax/ts/src/app/app.component.ts', 'setStyles')(format=".")
:marked
  다음과 같이 `NgStyle` 프로퍼티 바인딩을 추가하여 `currentStyles`가 엘리먼트의 스타일을 설정하도록 하세요:

  Adding an `ngStyle` property binding to `currentStyles` sets the element's styles accordingly:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgStyle-2')(format=".")
.l-sub-section
  :marked
    종속되는 프로퍼티가 변경되거나 초기화 할 때, `setCurrentStyles()`를 호출하는 것은 여러분에게 달려있습니다.

    It's up to you to call `setCurrentStyles()`, both initially and when the dependent properties change.

a(href="#toc") back to top

.l-hr
a#ngModel
:marked
  ### NgModel - <span class="syntax">[(ngModel)]</span>로 폼 요소에 양방향 바인딩
  ### NgModel - Two-way binding to form elements with <span class="syntax">[(ngModel)]</span>
  
  데이터 입력 양식을 개발할 때, 사용자가 변경하면 데이터 프로퍼티를 표시하고 해당 속성을 업데이트하는 경우가 많습니다.

  When developing data entry forms, you often both display a data property and 
  update that property when the user makes changes.

  `NgModel` 지시자와 양방향 데이터 바인딩은 그렇게 쉽게 만듭니다. 다음은 그 예입니다:

  Two-way data binding with the `NgModel` directive makes that easy. Here's an example:
+makeExcerpt('src/app/app.component.html', 'NgModel-1', '')

+ifDocsFor('ts|js')
  :marked
    #### _FormsModule_은 _ngModel_을 사용해야합니다.
    #### _FormsModule_ is required to use _ngModel_

    양방향 데이터 바인딩에서 `ngModel`지시자를 사용하기 전에 `FormsModule`을 가져 와서 Angular 모듈의 `imports`리스트에 추가해야합니다.
    [Forms](../guide/forms.html#ngModel) 가이드의 `FormsModule` 과 `ngModel`에 대해 자세히 알아보세요.

    Before using the `ngModel` directive in a two-way data binding,
    you must import the `FormsModule` and add it to the Angular module's `imports` list.
    Learn more about the `FormsModule` and `ngModel` in the
    [Forms](../guide/forms.html#ngModel) guide.

    `FormsModule`을 임포트하여 `[(ngModel)]`을 사용할수 있게하는 방법은 다음과 같습니다.

    Here's how to import the `FormsModule` to make `[(ngModel)]` available.
  +makeExcerpt('src/app/app.module.1.ts (FormsModule import)', '')

:marked
  #### 내부 <span class="syntax">[(ngModel)]</span>
  #### Inside <span class="syntax">[(ngModel)]</span>

  `firstName` 바인딩을 살펴보면,
  `input`요소의 `value`속성과 `input`이벤트에 대한 별도의 바인딩을 사용하여 동일한 결과를 얻을 수 있었습니다.

  Looking back at the `firstName` binding, note that
  you could have achieved the same result with separate bindings to
  the `<input>` element's  `value` property and `input` event.
+makeExample('template-syntax/ts/src/app/app.component.html', 'without-NgModel')(format=".")
:marked
  매우 번거롭죠. 어떤 요소 속성을 설정하고 어떤 요소 이벤트가 사용자 변경 사항을 발생 시키는지 누가 기억할 수 있습니까?
  어떻게 데이터 속성을 업데이트 할 수 있도록 입력 상자에서 현재 표시된 텍스트를 뽑아낼까요?
  누가 매번 그걸 보길 원할까요?

  That's cumbersome. Who can remember which element property to set and which element event emits user changes?
  How do you extract the currently displayed text from the input box so you can update the data property?
  Who wants to look that up each time?


  `ngModel` 지시자는 자신의 `ngModel` 입력과 `ngModelChange` 출력 속성 뒤에 이러한 번거로운 세부 사항을 숨 깁니다.

  That `ngModel` directive hides these onerous details behind its own  `ngModel` input and `ngModelChange` output properties.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgModel-3')(format=".")
.l-sub-section
  :marked
    `ngModel` 데이터 속성은 요소의 값 속성을 설정하고, `ngModelChange` 이벤트 속성은 요소 값의 변경 사항을 수신합니다.

    The `ngModel` data property sets the element's value property and the `ngModelChange` event property
    listens for changes to the element's value.
    
    세부사항은 각 요소의 종류에 따라 다르므로 `NgModel` 지시자는 요소가 프로토콜에 적용하는 [ControlValueAccessor](../api/forms/index/ControlValueAccessor-interface.html)가 지원하는 요소에 대해서만 작동합니다.
    `<input>`상자는 그 요소 중 하나입니다.
    Angular는 모든 기본 HTML 폼 요소에 *value accessors*를 제공하고 [_폼_](forms.html) 가이드에는 그것들을 어떻게 바인딩하는지 나와 있습니다.

    The details are specific to each kind of element and therefore the `NgModel` directive only works for an element 
    supported by a [ControlValueAccessor](../api/forms/index/ControlValueAccessor-interface.html)
    that adapts an element to this protocol.
    The `<input>` box is one of those elements.
    Angular provides *value accessors* for all of the basic HTML form elements and the
    [_Forms_](forms.html) guide shows how to bind to them.

    이 가이드의 범위를 벗어나는 기술인 적절한 *value accessor*를 작성할 때까지, 폼이 아닌 기본 요소 또는 써드파티 사용자 지정 구성 요소에 `[(ngModel)]`을 적용 할 수 없습니다.

    You can't apply `[(ngModel)]` to a non-form native element or a third-party custom component until you write a suitable *value accessor*,
    a technique that is beyond the scope of this guide.
    
    Angular의 기본 [양방향 바인딩 구문](#two-way)에 맞게하고 `NgModel`을 건너 뛰기 위해 값 및 이벤트 속성의 이름을 지정할 수 있으므로 작성하는 Angular 구성 요소에는 _value accessor_가 필요하지 않습니다.
    [위의 `sizer`](#two-way)는 이 기술의 한 예입니다.

    You don't need a _value accessor_ for an Angular component that you write because you can name the value and event properties
    to suit Angular's basic [two-way binding syntax](#two-way) and skip `NgModel` altogether.
    The [`sizer` shown above](#two-way) is an example of this technique.

:marked
  별도의 `ngModel` 바인딩은 요소의 네이티브 속성에 바인딩하는 것보다 개선된 기능입니다. 당신은 더 잘 수 있어요.

  Separate `ngModel` bindings is an improvement over binding to the element's native properties. You can do better.

  데이터 속성을 두 번 언급하지 않아도 됩니다.
  Angular는 컴포넌트의 데이터 속성을 캡처하고 `[(ngModel)]` 구문을 사용하여 단일 선언으로 설정할 수 있어야 합니다:

  You shouldn't have to mention the data property twice. Angular should be able to capture the component's data property and set it
  with a single declaration, which it can with the `[(ngModel)]` syntax:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgModel-1')(format=".")
:marked
  `[(ngModel)]`이 모두 필요할까요? 확장 된 형태로 돌아갈 이유가 있을까요?

  Is `[(ngModel)]` all you need? Is there ever a reason to fall back to its expanded form?

  `[(ngModel)]` 구문은 데이터 바인딩된 속성 만 가질 수 있습니다.
  더 많은 것을 하거나 뭔가 다른 것을해야 한다면, 확장된 폼을 작성할 수 있습니다.

  The `[(ngModel)]` syntax can only _set_ a data-bound property.
  If you need to do something more or something different, you can write the expanded form.

  다음의 인위적인 예는 입력값을 대문자로 강제합니다:

  The following contrived example forces the input value to uppercase:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgModel-4')(format=".")
:marked
  Here are all variations in action, including the uppercase version:
figure.image-display
    img(src='/resources/images/devguide/template-syntax/ng-model-anim.gif' alt="NgModel variations")
:marked
  &nbsp;

a(href="#toc") back to top

.l-hr
a#structural-directives
:marked
  ## 내장 _구조_ 지시문
  ## Built-in _structural_ directives

  구조 지시자는 HTML 레이아웃을 담당합니다.
  일반적으로 DOM은 호스트 요소를 추가, 제거 및 조작하여 DOM _구조_를 형성하거나 변형합니다.

  Structural directives are responsible for HTML layout.
  They shape or reshape the DOM's _structure_, typically by adding, removing, and manipulating
  the host elements to which they are attached.

  구조 지시문에 대한 자세한 내용은 [_구조 지시자_](structural-directives.html) 가이드에서 다룰 것입니다:

  The deep details of structural directives are covered in the 
  [_Structural Directives_](structural-directives.html) guide
  where you'll learn:

  * [_지시자 이름앞에 별표(\*)를 붙이는 이유_](structural-directives.html#asterisk "The * in *ngIf")
  
  * why you 
  [_prefix the directive name with an asterisk_ (\*)](structural-directives.html#asterisk "The * in *ngIf").
  
  * 지시자에 적합한 호스트 요소가 없을 때 요소를 그룹화하기 위해 [`<ng-container>`](structural-directives.html#ngcontainer "<ng-container>")를 사용

  * to use [`<ng-container>`](structural-directives.html#ngcontainer "<ng-container>")
  to group elements when there is no suitable host element for the directive.
  
  * 자신의 구조 지시자 작성 방법

  * how to write your own structural directive.
  
  * [하나의 구조 지시자](structural-directives.html#one-per-element "one per host element")에만 적용 할 수 있습니다.

  * that you can only apply [one structural directive](structural-directives.html#one-per-element "one per host element") to an element.

  _이_ 절은 일반적인 구조 지시자에 대해 소개합니다.

  _This_ section is an introduction to the common structural directives:

  * [`NgIf`](#ngIf) - 조건부로 DOM에 요소를 추가하거나 제거합니다.

  * [`NgIf`](#ngIf) - conditionally add or remove an element from the DOM

  * [`NgFor`](#ngFor) - 목록의 각 항목에 템플릿을 반복합니다.

  * [`NgFor`](#ngFor) - repeat a template for each item in a list

  * [`NgSwitch`](#ngSwitch) - 대체 뷰를 전환하는 지시자 모음입니다.

  * [`NgSwitch`](#ngSwitch) - a set of directives that switch among alternative views

.l-hr
a#ngIf
:marked
  ### NgIf
  ### NgIf
  
  (_호스트 요소_라고 부르는) 해당 요소에 `NgIf` 지시자를 적용하여 DOM에 요소를 추가하거나 제거 할 수 있습니다.
  이 예제에서 지시자를 `isActive`와 같은 조건식에 바인딩하세요.

  You can add or remove an element from the DOM by applying an `NgIf` directive to
  that element (called the _host elment_).
  Bind the directive to a condition expression like `isActive` in this example.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgIf-1')(format=".")

.alert.is-critical
  :marked
    `ngIf` 앞에 별표 (`*`)를 잊지 마세요.

    Don't forget the asterisk (`*`) in front of `ngIf`.
:marked
  `isActive` 표현식이 #{_truthy} 값을 반환하면, `NgIf`는 `HeroDetailComponent`를 DOM에 추가합니다.
  표현식이 #{_falsy}인 경우, `NgIf`는 DOM에서 `HeroDetailComponent`를 제거하여 해당 컴포넌트와 모든 하위 컴포넌트를 파괴합니다.

  When the `isActive` expression returns a #{_truthy} value, `NgIf` adds the `HeroDetailComponent` to the DOM.
  When the expression is #{_falsy}, `NgIf` removes the `HeroDetailComponent`
  from the DOM, destroying that component and all of its sub-components.

block dart-no-truthy-falsy
  //- N/A

:marked
  #### 보여주기/숨기기는 같은 것이 아닙니다.
  #### Show/hide is not the same thing
  You can control the visibility of an element with a
  [class](#class-binding) or [style](#style-binding) binding:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgIf-3')(format=".")
:marked
  Hiding an element is quite different from removing an element with `NgIf`.

  When you hide an element, that element and all of its descendents remain in the DOM.
  All components for those elements stay in memory and
  Angular may continue to check for changes.
  You could be holding onto considerable computing resources and degrading performance, 
  for something the user can't see.

  When `NgIf` is `false`, Angular physically removes the element and its descendents from the DOM.
  It destroys their components, potentially freeing up substantial resources,
  resulting in a more responsive user experience.

  The show/hide technique is fine for a few elements with few children.
  You should be wary when hiding large component trees; `NgIf` may be the safer choice. 

  #### Guard against null objects
  The `ngIf` directive is often used to guard against a null object.
  Show/hide is useless as a guard.
  Angular will throw an error if a nested expression tries to access a property of a null object,
  whether its visible or not.

  Here we see `NgIf` guarding two `<div>`s. 
  The `currentHero` name will appear only when there is a `currentHero`.
  The `nullHero` will never be displayed.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgIf-2')(format=".")

.l-sub-section
  :marked
    아래에 설명한 [_안전한 네비게이션 연산자_](#safe-navigation-operator "Safe naviation operator (?.)")를 참조하세요.

    See also the 
    [_safe navigation operator_](#safe-navigation-operator "Safe naviation operator (?.)") 
    described below.

a(href="#toc") back to top

.l-hr
a#ngFor
:marked
  ### NgFor
  ### NgFor

  `NgFor`는 지시자 _반복기_ 입니다 &mdash;데이터 표시를 사용자 정의하는 방법.
  단일 아이템이 어떻게 보여야 하는지를 정의하는 HTML 블록을 정의합니다.
  그리고 Angular에게 목록의 각 아이템을 렌더링하는 템플릿으로 해당 블록을 사용하라고 알려줍니다.

  `NgFor` is a _repeater_ directive &mdash; a way to present a list of items.
  You define a block of HTML that defines how a single item should be displayed.
  You tell Angular to use that block as a template for rendering each item in the list.

  다음은 간단한 `<div>`에 적용된 `NgFor`의 예제입니다:

  Here is an example of `NgFor` applied to a simple `<div>`:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgFor-1')(format=".")
:marked
  또한 다음 예제처럼 컴포넌트 엘리먼트에 `NgFor`를 적용할 수도 있습니다:

  You can also apply an `NgFor` to a component element, as in this example:
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgFor-2')(format=".")

.alert.is-critical
  :marked
    `ngFor` 앞의 별표 (`*`)를 잊지 마세요.
    [\* 와 &lt;template>](#star-template)에서 자세한 내용을 확인하세요.

    Don't forget the asterisk (`*`) in front of `ngFor`.

:marked
  `*ngFor`에 할당된 텍스트는 반복기 프로세스를 안내하는 명령문입니다.

  The text assigned to `*ngFor` is the instruction that guides the repeater process.

a#microsyntax
:marked
  #### *NgFor 세부구문(microsyntax)
  #### *ngFor microsyntax

  `*ngFor`에 할당된 문자열은 [템플릿 표현식](#template-expressions)이 아닙니다.
  그것은 *세부구문(microsyntax)* &mdash; Angular가 해석하는 자체의 작은 언어입니다. 이번 예제에서 `"let hero of heroes"` 문자열은 다음을 뜻합니다:

  The string assigned to `*ngFor` is not a [template expression](#template-expressions).
  It's a *microsyntax* &mdash; a little language of its own that Angular interprets. 
  The string `"let hero of heroes"` means:

  > *`히어로` #{_배열}에서 각 히어로를 가져 와서 지역의 `히어로` 루프 변수에 저장하고, 각 반복마다 템플릿 HTML에서 사용할 수 있게 하세요.*

  > *Take each hero in the `heroes` #{_array}, store it in the local `hero` looping variable, and 
  make it available to the templated HTML for each iteration.*

  Angular는 이 명령어를 호스트 요소 주위의 `<template>`으로 변환합니다. 그 다음 템플릿을 반복적으로 사용하여 목록에 있는 각 `hero`에 대한 새로운 요소와 바인딩 세트를 만듭니다.

  Angular translates this instruction into a `<template>` around the host element,
  then uses this template repeatedly to create a new set of elements and bindings for each `hero` 
  in the list.

:marked
  [_구조 지시자_](structural-directives.html#microsyntax) 가이드의 _세부구문_에 대해 자세히 알아보세요.

  Learn about the _microsyntax_ in the [_Structural Directives_](structural-directives.html#microsyntax) guide.

a#template-input-variable  
a#template-input-variables
:marked
  ### 템플릿 입력 변수
  ### Template input variables

  `hero` 전에 `let` 키워드는 `hero`라고하는 _템플릿 입력 변수_를 만듭니다. 
  `ngFor` 지시자는 부모 구성 요소의 `heroes` 속성에 의해 반환 된 `heroes` 배열을 반복하고
  각 반복 동안에 배열의 현재 항목으로 `hero`요소를 설정합니다.

  The `let` keyword before `hero` creates a _template input variable_ called `hero`.
  The `ngFor` directive iterates over the `heroes` #{_array} returned by the parent component's `heroes` property
  and sets the `hero` element with the current item from the #{_array} during each iteration.

  히어로의 속성에 액세스하려면 `ngFor` 호스트 요소 (및 그 하위 요소) 내의 `hero` 입력 변수를 참조하세요.
  여기서는 삽입식에서 처음 참조되고, `<hero-detail>` 컴포넌트의 `hero` 속성에 바인딩되어 전달됩니다.

  You reference the `hero` input variable within the `ngFor` host element (and within its descendents) to access the hero's properties.
  Here it is referenced first in an interpolation and then passed in a binding to the `hero` property of the `<hero-detail>` component.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgFor-1-2')(format=".")  

:marked
  _템플릿 입력 변수_에 대한 자세한 내용은 [구조 지시자](structural-directives.html#template-input-variable) 안내서를 참조하세요.

  Learn more about _template input variables_ in the [_Structural Directives_](structural-directives.html#template-input-variable) guide.

  #### *ngFor _색인_
  #### *ngFor with _index_

  `NgFor` 지시자 컨텍스트의 `index` 속성은 각 반복에서 항목의 0부터 시작하는 인덱스를 반환합니다.
  템플릿 입력 변수에 `index`를 포착하여 템플릿에서 사용할 수 있습니다.

  The `index` property of the `NgFor` directive context  returns the zero-based index of the item in each iteration.
  You can capture the `index` in a template input variable and use it in the template.

  다음 예제는 `i`라는 변수에서`index`를 캡쳐하고 이것을 히어로 이름과 함께 표시합니다.

  The next example captures the `index` in a variable named `i` and displays it with the hero name like this.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgFor-3')(format=".")
.l-sub-section
  :marked
    [NgFor API 참조](../api/common/index/NgFor-directive.html)에서 `last`,`even`,`odd`와 같은 다른 `NgFor` 컨텍스트 값에 대해 배웁니다.

    Learn about the other `NgFor` context values such as `last`, `even`, and `odd` in the [NgFor API reference](../api/common/index/NgFor-directive.html).

a#trackBy
:marked
  #### *_trackBy_와 ngFor 
  #### *ngFor with _trackBy_
  
  `NgFor` 지시자는 성능이 좋지 않을 수 있으며 특히 큰 목록의 경우 성능이 떨어질 수 있습니다.
  하나의 항목, 제거 된 항목 또는 추가된 항목에 대한 작은 변경으로 인해 DOM 조작이 계단식으로 실행될 수 있습니다.

  The `NgFor` directive may perform poorly, especially with large lists.
  A small change to one item, an item removed, or an item added can trigger a cascade of DOM manipulations.

  예를 들어 서버를 다시 쿼리하면 모든 새로운 히어로 객체로 목록이 재설정 될 수 있습니다.

  For example, re-querying the server could reset the list with all new hero objects.

  전부는 대부분 아니지만 이전의 영웅으로 표시됩니다.
  각 히어로의 `id`가 바뀌지 않았기 때문에 이것을 알 수 있습니다.
  그러나 Angular는 새로운 객체 참조의 새로운 목록만 봅니다.
  이전 DOM 요소를 분해하고 모든 새 DOM 요소를 삽입 할 수 밖에 없습니다.

  Most, if not all, are previously displayed heroes.
  *You* know this because the `id` of each hero hasn't changed.
  But Angular sees only a fresh list of new object references.
  It has no choice but to tear down the old DOM elements and insert all new DOM elements.

  Angular는`trackBy`를 사용하여 이것을 피할 수 있습니다.
  `NgFor`가 _추적해야 할_ 값을 리턴하는 메소드를 컴포넌트에 추가하십시오.
  이 경우, 그 값은 히어로의 `id`입니다.

  Angular can avoid this churn with `trackBy`.
  Add a method to the component that returns the value `NgFor` _should_ track.
  In this case, that value is the hero's `id`.
+makeExample('template-syntax/ts/src/app/app.component.ts', 'trackByHeroes')(format=".")

:marked
  세부구문 표현식에서 이 메소드로 `trackBy`를 설정하세요.

  In the microsyntax expression, set `trackBy` to this method.
+makeExample('template-syntax/ts/src/app/app.component.html', 'trackBy')(format=".")

:marked
  _trackBy_ 효과를 보여주는 그림입니다.
  "Reset heroes"는 같은 `hero.id`로 새로운 영웅을 만듭니다.
  "Change ID"는 새로운 `hero.id`로 새로운 영웅을 만듭니다.

  Here is an illustration of the _trackBy_ effect.
  "Reset heroes" creates new heroes with the same `hero.id`s.
  "Change ids" creates new heroes with new `hero.id`s.

  * `trackBy`가 없으면 두 버튼 모두 DOM 요소를 완전히 대체합니다.
  
  * With no `trackBy`, both buttons trigger complete DOM element replacement.
  
  * `trackBy`로, `id`만 변경하면 요소 교체가 시작됩니다.

  * With `trackBy`, only changing the `id` triggers element replacement. 

figure.image-display
  img(src='/resources/images/devguide/template-syntax/ng-for-track-by-anim.gif' alt="trackBy")

a(href="#toc") back to top

.l-hr
a#ngSwitch
:marked
  ### _NgSwitch_ 지시자
  ### The _NgSwitch_ directives

  *NgSwitch*는 JavaScript의 switch문과 같습니다.
  _switch 조건 _에 따라 여러 가능한 요소 중 _하나의_ 요소를 표시 할 수 있습니다.
  Angular는 *선택된* 요소만 DOM에 넣습니다.

  *NgSwitch* is like the JavaScript `switch` statement.
  It can display _one_ element from among several possible elements, based on a _switch condition_.
  Angular puts only the *selected* element into the DOM.

  *NgSwitch* is actually a set of three, cooperating directives:
  `NgSwitch`, `NgSwitchCase`, and `NgSwitchDefault` as seen in this example.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgSwitch')(format=".")

figure.image-display
  img(src='/resources/images/devguide/template-syntax/switch-anim.gif' alt="trackBy")
:marked
  `NgSwitch`는 컨트롤러 지시자입니다. 그것을 *스위치 값*을 반환하는 표현식에 바인딩합니다.
  이 예제에서 `emotion` 값은 문자열이지만 스위치 값은 어떤 형태든 될 수 있습니다.

  `NgSwitch` is the controller directive. Bind it to an expression that returns the *switch value*.
  The `emotion` value in this example is a string, but the switch value can be of any type.

  **`[ngSwitch]`에 바인딩하세요**. `*ngSwitch`를 설정하려고 하면 오류가 발생할 겁니다.
  `NgSwitch`는 *구조* 지시자가 아닌 *속성* 지시자입니다.
  그것은 동반자 지시자의 동작을 변경합니다.
  DOM에 직접적으로 영향을주지 않습니다.

  **Bind to `[ngSwitch]`**. You'll get an error if you try to set `*ngSwitch`.
  `NgSwitch` is an *attribute* directive, not a *structural* directive.
  It changes the behavior of its companion directives.
  It doesn't touch the DOM directly.

  **`*ngSwitchCase` 및 `*ngSwitchDefault`에 바인딩하세요**.
  `NgSwitchCase`와 `NgSwitchDefault` 지시자는 DOM에서 요소를 추가하거나 제거하기 때문에 _구조_ 지시자입니다.

  **Bind to `*ngSwitchCase` and `*ngSwitchDefault`**.
  The `NgSwitchCase` and `NgSwitchDefault` directives are _structural_ directives
  because they add or remove elements from the DOM.

  * `NgSwitchCase`는 바운드 값이 스위치 값과 같을 때 그 요소를 DOM에 추가합니다.

  * `NgSwitchCase` adds its element to the DOM when its bound value equals the switch value.

  * `NgSwitchDefault`는 선택된 `NgSwitchCase`가 없을 때 그 요소를 DOM에 추가합니다.

  * `NgSwitchDefault` adds its element to the DOM when there is no selected `NgSwitchCase`.

  스위치 지시자은 *컴포넌트 요소*를 추가 및 제거하는 데 특히 유용합니다.
  이 예제는 `hero-switch.components.ts` 파일에 정의 된 4개의 "감정적 히어로" 컴포넌트 사이를 전환합니다.
  각 컴포넌트는 부모 컴포넌트의 `currentHero`에 바인딩 된 `히어로` [입력 속성](#inputs-outputs "Input property")을 가지고 있습니다.

  The switch directives are particularly useful for adding and removing *component elements*.
  This example switches among four "emotional hero" components defined in the `hero-switch.components.ts` file.
  Each component has a `hero` [input property](#inputs-outputs "Input property") 
  which is bound to the `currentHero` of the parent component.

  스위치 지시자는 네이티브 요소 및 웹 컴포넌트와도 잘 동작합니다.
  예를 들어, `<confused-hero>` 스위치의 경우를 다음과 같이 바꿀 수 있습니다.

  Switch directives work as well with native elements and web components too.
  For example, you could replace the `<confused-hero>` switch case with the following.
+makeExample('template-syntax/ts/src/app/app.component.html', 'NgSwitch-div')(format=".")

a(href="#toc") back to top

.l-hr
a#template-reference-variable
a#ref-vars
a#ref-var
:marked
  ## 템플릿 참조 변수 ( <span class="syntax">#var</span> )
  ## Template reference variables ( <span class="syntax">#var</span> )

:marked
  **템플릿 참조 변수**는 템플릿 내의 DOM 요소에 대한 참조인 경우가 많습니다.
  또한 Angular 컴포넌트나 지시자 또는 <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" title="MDN: Web Components">웹 컴포넌트</a>에 대한 참조 일 수도 있습니다.

  A **template reference variable** is often a reference to a DOM element within a template.
  It can also be a reference to an Angular component or directive or a 
  <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components" target="_blank" title="MDN: Web Components">web component</a>.

  해시 기호(#)를 사용하여 참조 변수를 선언하세요.
  `#phone`은 `<input>`요소에 `phone` 변수를 선언합니다.

  Use the hash symbol (#) to declare a reference variable.
  The `#phone` declares a `phone` variable on an `<input>` element.
+makeExample('template-syntax/ts/src/app/app.component.html', 'ref-var')(format=".")
:marked
  템플릿 참조 변수는 템플릿의 _어느곳_에서나 참조 할 수 있습니다.
  이 `<input>`에서 선언 된 `phone` 변수는 템플릿의 반대편에 있는 `<button>`에서 사용됩니다

  You can refer to a template reference variable _anywhere_ in the template.
  The `phone` variable declared on this `<input>` is 
  consumed in a `<button>` on the other side of the template
+makeExample('template-syntax/ts/src/app/app.component.html', 'ref-phone')(format=".")

:marked
  ### 참조 변수가 값을 얻는 방법
  ### How a reference variable gets its value

  대부분의 경우, Angular는 참조 변수의 값을 선언된 요소로 설정합니다.
  앞의 예에서 `phone`은 _phone number_`<input>` 상자를 가리킵니다.
  phone button 클릭 핸들러는 _입력_ 값을 컴포넌트의 `callPhone` 메소드에 전달합니다.
  그러나 지시자는 그 행동을 바꿀 수 있고 값을 그 자체와 같은 다른 것으로 설정할 수 있습니다.
  `NgForm` 지시자는 그렇게 합니다.

  In most cases, Angular sets the reference variable's value to the element on which it was declared.
  In the previous example, `phone` refers to the _phone number_ `<input>` box.
  The phone button click handler passes the _input_ value to the component's `callPhone` method.
  But a directive can change that behavior and set the value to something else, such as itself.
  The `NgForm` directive does that.

  다음은 [폼](forms.html) 가이드에 있는 폼 예제의 *단순화 된* 버전입니다.

  The following is a *simplified* version of the form example in the [Forms](forms.html) guide.
+makeExample('template-syntax/ts/src/app/hero-form.component.html')(format=".")
:marked
  이 예제에서 3번 나타나는, 템플릿 참조 변수인 `heroForm`은 많은 양의 HTML로 구분됩니다.
  `heroForm`의 값은 무엇입니까?

  A template reference variable, `heroForm`, appears three times in this example, separated
  by a large amount of HTML.
  What is the value of `heroForm`?

  Angular가 `FormsModule`을 가져 왔을 때 그것을 끝내지 않았다면, 그것은 [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement)가 됩니다.
  `heroForm`은 실제로 폼의 모든 컨트롤의 값과 유효성을 추적 할 수있는 Angular [NgForm](../api/forms/index/NgForm-directive.html "API: NgForm") 지시자에 대한 참조입니다.

  If Angular hadn't taken it over when you imported the `FormsModule`,
  it would be the [HTMLFormElement](https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement).
  The `heroForm` is actually a reference to an Angular [NgForm](../api/forms/index/NgForm-directive.html "API: NgForm") 
  directive with the ability to track the value and validity of every control in the form.

  네이티브 `<form>`요소에는 `form` 속성이 없습니다.
  그러나 `heroForm.form.valid`가 유효하지 않은 경우 submit 버튼을 어떻게 비활성화시킬 수 있는지 설명해주고 전체 폼 컨트롤 트리를 부모 컴포넌트의 `onSubmit` 메소드로 넘겨주는, `NgForm` 지시자가 있습니다.

  The native `<form>` element doesn't have a `form` property.
  But the `NgForm` directive does, which explains how you can disable the submit button 
  if the `heroForm.form.valid` is invalid and pass the entire form control tree 
  to the parent component's `onSubmit` method.

  ### 템플릿 참조 변수 유의사항
  ### Template reference variable warning notes

  템플릿 _참조_ 변수 (`# phone`)는 [`*ngFor`](#template-input-variable)에서 볼 수있는 것과 같은 템플릿 _입력_ 변수 (`let phone`)와 같지 않습니다.
  [_구조 지시자_](structural-directives.html#template-input-variable) 가이드에서 차이점을 확인해보세요.

  A template _reference_ variable (`#phone`) is _not_ the same as a template _input_ variable (`let phone`)
  such as you might see in an [`*ngFor`](#template-input-variable).
  Learn the difference in the [_Structural Directives_](structural-directives.html#template-input-variable) guide.

  참조 변수의 범위는 _전체 템플릿_입니다. 
  동일한 템플릿에서 동일한 변수 이름을 두 번 이상 정의하지 마세요.
  런타임 값은 예측할 수 없습니다.

  The scope of a reference variable is the _entire template_.
  Do not define the same variable name more than once in the same template.
  The runtime value will be unpredictable.

  `#` 대신 `ref-`접두어를 사용할 수 있습니다.
  이 예제는 `fax` 변수를 `#fax` 대신에 `ref-fax`로 선언합니다.

  You can use the `ref-` prefix alternative to `#`.
  This example declares the `fax` variable as `ref-fax` instead of `#fax`.
+makeExample('template-syntax/ts/src/app/app.component.html', 'ref-fax')(format=".")

a(href="#toc") back to top

.l-hr
a#inputs-outputs
:marked
  ## 입력과 출력 속성 ( <span class="syntax">@Input</span>과 <span class="syntax">@Output</span> )
  ## Input and output properties ( <span class="syntax">@Input</span> and <span class="syntax">@Output</span> )

  지금까지는 *바인딩 선언의 오른쪽*에 나타나는 템플릿 표현식 및 명령문 내의 컴포넌트 멤버에 주로 바인딩하는 방법을 중점적으로 설명했습니다.
  해당 위치에 있는 멤버는 데이터 바인딩 **소스**입니다.

  So far, you've focused mainly on binding to component members within template expressions and statements
  that appear on the *right side of the binding declaration*.
  A member in that position is a data binding **source**.

  이번 섹션에서는 *바인딩 선언의 왼쪽*에 있는 지시자 프로퍼티인
  **타깃**에 바인딩하는 것에 집중하겠습니다.
  이러한 지시자 프로퍼티는 반드시 **input**이나 **output**으로 선언되어야 합니다.

  This section concentrates on binding to **targets**, which are directive
  properties on the *left side of the binding declaration*.
  These directive properties must be declared as **inputs** or **outputs**.

.alert.is-important
  :marked
    모든 **컴포넌트**는 **지시자** 임을 기억하세요.

    Remember: All **components** are **directives**.
:marked
.l-sub-section
  :marked
    데이터 바인딩 **타깃**과 데이터 바인딩 **소스** 를 뚜렷하게 구별하고 있습니다.

    You're drawing a sharp distinction between a data binding **target** and a data binding **source**.

    바인딩 *타깃*은 `=`의 *왼쪽*에 있습니다.
    *소스*는 `=`의 *오른쪽*에 있습니다.

    The *target* of a binding is to the *left* of the `=`.
    The *source* is on the *right* of the `=`.

    바인딩 *타깃*은 `[]`, `()`, `[()]`와 같은 바인딩 구두점 안에 있는 프로퍼티나 이벤트입니다.
    *소스*는 따옴표 (`" "`)나 삽입식 (`{{}}`) 안에 있을 수 있습니다.

    The *target* of a binding is the property or event inside the binding punctuation: `[]`, `()` or `[()]`.
    The *source* is either inside quotes (`" "`) or within an interpolation (`{{}}`).

    **소스** 지시자의 모든 멤버는 자동으로 바인딩에 사용할 수 있습니다.
    템플릿 표현식이나 명령문 안의 지시자 멤버에 접근하기 위해 특별한 것을 할 필요는 없습니다.

    Every member of a **source** directive is automatically available for binding.
    You don't have to do anything special to access a directive member in a template expression or statement.

    **타깃** 지시자의 멤버에 *제한된* 접근을 할 수 있습니다.
    우리는 오직 *input*과 *output*으로 명시적으로 식별된 프로퍼티에만 바인딩할 수 있습니다.    

    You have *limited* access to members of a **target** directive.
    You can only bind to properties that are explicitly identified as *inputs* and *outputs*.
:marked
  다음 구문에서 `iconUrl`과 `onSave`는 `AppComponent`의 데이터 바인딩된 멤버로 
  등호&nbsp;(`=`)의 오른쪽에 따옴표 된 구문안에서 참조됩니다.

  In the following snippet, `iconUrl` and `onSave` are data-bound members of the `AppComponent`
  and are referenced within quoted syntax to the _right_ of the equals&nbsp;(`=`).
+makeExample('template-syntax/ts/src/app/app.component.html', 'io-1')(format=".")
:marked
  이것들은 컴포넌트의 *input이나 output*이 아닙니다. 이것들은 바인딩의 데이터 소스입니다.
  대상은 네이티브 `<image>`와`<button>`요소입니다.

  They are *neither inputs nor outputs* of the component. They are **sources** for their bindings.
  The targets are the native `<img>` and `<button>` elements.

  이제는 `HeroDetailComponent`가 등호&nbsp;(`=`)의 _왼쪽_에 있는 바인딩의 **대상**이 되는 다른 구문을 살펴보세요.

  Now look at a another snippet in which the `HeroDetailComponent` is the **target** of a binding on the _left_ of the equals&nbsp;(`=`).
+makeExample('template-syntax/ts/src/app/app.component.html', 'io-2')(format=".")
:marked
  `HeroDetailComponent.hero`와 `HeroDetailComponent.deleteRequest`는 바인딩 선언의 **왼쪽**에 있습니다.
  `HeroDetailComponent.hero`는 대괄호 안에 있습니다; 이것은 프로퍼티 바인딩의 타깃입니다.
  `HeroDetailComponent.deleteRequest`는 소괄호 안에 있습니다; 이것은 이벤트 바인딩의 타깃입니다.

  Both `HeroDetailComponent.hero` and `HeroDetailComponent.deleteRequest` are on the **left side** of binding declarations.
  `HeroDetailComponent.hero` is inside brackets; it is the target of a property binding.
  `HeroDetailComponent.deleteRequest` is inside parentheses; it is the target of an event binding.

  ### input과 output 프로퍼티 선언하기
  ### Declaring input and output properties

  타깃 프로퍼티는 반드시 명시적으로 input이나 output으로 표기되어야 합니다.

  Target properties must be explicitly marked as inputs or outputs.

  `HeroDetailComponent` 내부에, 이러한 속성은 입력과 출력 속성같은 데코레이터로 표시됩니다.
  
  In the `HeroDetailComponent`, such properties are marked with decorators as input and output properties.
+makeExample('template-syntax/ts/src/app/hero-detail.component.ts', 'input-output-1')(format=".")

:marked
.l-sub-section
  :marked
    또는 다음 예제처럼 지시자 메타데이터의 `inputs` 과 `outputs` #{_array_ko}에 멤버로 정의할 수 있습니다.

    Alternatively, you can identify members in the `inputs` and `outputs` #{_array}s
    of the directive metadata, as in this example:
  +makeExample('template-syntax/ts/src/app/hero-detail.component.ts', 'input-output-2')(format=".")
  <br>
  :marked
    input/output 프로퍼티를 데코레이터 또는 메타데이터 #{_array_ko} 중 한 가지 방식으로 정의할 수 있습니다.
    두 가지 방식을 모두 사용하면 안 됩니다!

    You can specify an input/output property either with a decorator or in a metadata #{_array}.
    Don't do both!
:marked
  ### Input or output?
  ### Input or output?

  *인풋* 프로퍼티는 일반적으로 데이터 값을 받습니다.
  *아웃풋* 프로퍼티는 `EventEmitter` 객체 같은 이벤트 생산자를 노출합니다.

  *Input* properties usually receive data values.
  *Output* properties expose event producers, such as `EventEmitter` objects.

  _input_과 _output_이라는 용어는 타깃 지시자의 관점을 반영합니다.

  The terms _input_ and _output_ reflect the perspective of the target directive.
figure.image-display
    img(src='/resources/images/devguide/template-syntax/input-output.png' alt="Inputs and outputs")
:marked
  `HeroDetailComponent.hero`는 `HeroDetailComponent` 관점에서 *input* 프로퍼티 입니다.
  왜냐하면 데이터가 템플릿 바인딩 표현식에서 해당 프로퍼티로 흘러 *들어가기* 때문입니다.

  `HeroDetailComponent.hero` is an **input** property from the perspective of `HeroDetailComponent`
  because data flows *into* that property from a template binding expression.

  `HeroDetailComponent.deleteRequest`은 `HeroDetailComponent` 관점에서 *output* 프로퍼티 입니다.
  왜냐하면 이벤트가 해당 프로퍼티에서 흘러 *나와서* 템플릿 바인딩 명령문의 핸들러를 향하기 때문입니다.

  `HeroDetailComponent.deleteRequest` is an **output** property from the perspective of `HeroDetailComponent`
  because events stream *out* of that property and toward the handler in a template binding statement.

h3#aliasing-io input/output 프로퍼티 별칭
h3#aliasing-io Aliasing input/output properties
:marked
  때로는 input/output 프로퍼티의 외부 이름이 내부 이름과 다르길 원할 때가 있습니다.

  Sometimes the public name of an input/output property should be different from the internal name.

  이것은 대부분 [속성 지시자](attribute-directives.html)인 경우입니다.
  지시자 소비자는 지시자의 이름에 바인딩하기를 기대합니다.
  예를 들어, `myClick` 셀렉터를 가진 지시자를 `<div>` 태그에 적용하려고 할때,
  `myClick` 이라는 이벤트 프로퍼티에 바인딩 되기를 원합니다.

  This is frequently the case with [attribute directives](attribute-directives.html).
  Directive consumers expect to bind to the name of the directive.
  For example, when you apply a directive with a `myClick` selector to a `<div>` tag,
  you expect to bind to an event property that is also called `myClick`.
+makeExample('template-syntax/ts/src/app/app.component.html', 'myClick')(format=".")
:marked
  하지만, 지시자 이름은 지시자 클래스의 프로퍼티 이름으로 안 좋은 선택입니다.
  지시자 이름은 프로퍼티가 하는 것을 거의 설명하지 못합니다.
  `myClick` 지시자 이름은 클릭 메시지를 방출하는 프로퍼티의 이름으로 좋지 않은 이름입니다.

  However, the directive name is often a poor choice for the name of a property within the directive class.
  The directive name rarely describes what the property does.
  The `myClick` directive name is not a good name for a property that emits click messages.

  다행히도, 내부적으로 다른 이름을 사용하면서도 관습적인 기대를 충족하는 
  외부용 프로퍼티 이름을 가질 수 있습니다.
  바로 위의 예제에서 사실은 `myClick` *별칭*을 *통해서*
  지시자의 자체 `clicks` 프로퍼티에 바인딩했습니다.

  Fortunately, you can have a public name for the property that meets conventional expectations,
  while using a different name internally.
  In the example immediately above, you are actually binding *through the* `myClick` *alias* to
  the directive's own `clicks` property.

  다음과 같이 input/output 데코레이더에 전달함으로써 프로퍼티 이름의 별칭을 정의할 수 있습니다:

  You can specify the alias for the property name by passing it into the input/output decorator like this:

+makeExample('template-syntax/ts/src/app/click.directive.ts', 'output-myClick')(format=".")

.l-sub-section
  :marked
    또한 `inputs`와 `outputs` #{_array_ko} 안에 프로퍼티 이름의 별칭을 붙일 수도 있습니다.
    *왼쪽*에 지시자 프로퍼티의 이름을 *오른쪽*에 외부용 별칭을 붙인 
    콜론 구분 (`:`) 문자열을 작성합니다.

    You can also alias property names in the `inputs` and `outputs` #{_array}s.
    You write a colon-delimited (`:`) string with
    the directive property name on the *left* and the public alias on the *right*:
  +makeExample('template-syntax/ts/src/app/click.directive.ts', 'output-myClick2')(format=".")

a(href="#toc") back to top

.l-hr 
a#expression-operators
:marked
  ## 템플릿 표현식 연산자
  ## Template expression operators

  템플릿 표현식 언어는 특정한 시나리오를 위해 몇가지 특별 연산자를 지원하는 #{_JavaScript} 문법의 서브셋을 사용하고 있습니다. 이 연산자들 중 2개를 다뤄보겠습니다: _pipe_와 _안전 내비게이션 연산자_입니다.

  The template expression language employs a subset of #{_JavaScript} syntax supplemented with a few special operators
  for specific scenarios. The next sections cover two of these operators: _pipe_ and _safe navigation operator_.

a#pipe
:marked
  ### 파이프 연산자 ( <span class="syntax">|</span> )
  ### The pipe operator ( <span class="syntax">|</span> )

  표현식의 결과를 바인딩에 사용하기 전에 일부 변형이 필요할 수 있습니다. 예를 들어 통화 표시, 대문자 강제전환, 목록 필터 후 정렬을 원할 수 있습니다.

  The result of an expression might require some transformation before you're ready to use it in a binding.
  For example, you might display a number as a currency, force text to uppercase, or filter a list and sort it.

  Angular [파이프](./pipes.html)는 이런 작은 변형을 위해 좋은 선택입니다.
  파이프는 입력 값을 받아서 변형된 값을 반환하는 간단한 함수입니다.
  **파이프 연산자 (`|`)**를 사용해 템플릿 표현식에 쉽게 적용할 수 있습니다.

  Angular [pipes](./pipes.html) are a good choice for small transformations such as these.
  Pipes are simple functions that accept an input value and return a transformed value.
  They're easy to apply within template expressions, using the **pipe operator (`|`)**:
+makeExample('template-syntax/ts/src/app/app.component.html', 'pipes-1')(format=".")
:marked
  파이프 연산자는 왼쪽 표현식의 결과를 오른쪽 파이프 함수로 전달합니다.

  The pipe operator passes the result of an expression on the left to a pipe function on the right.

  여러 파이프를 통해 표현식을 연결할 수도 있습니다:

  You can chain expressions through multiple pipes:
+makeExample('template-syntax/ts/src/app/app.component.html', 'pipes-2')(format=".")
:marked
  그리고 또한 파이프에 [파라미터 적용](./pipes.html#parameterizing-a-pipe)을 할 수 있습니다:

  And you can also [apply parameters](./pipes.html#parameterizing-a-pipe) to a pipe:
+makeExample('template-syntax/ts/src/app/app.component.html', 'pipes-3')(format=".")

block json-pipe
  :marked
    `json` 파이프는 바인딩을 디버깅 할 때 특히 유용합니다:

    The `json` pipe is particularly helpful for debugging bindings:
  +makeExample('template-syntax/ts/src/app/app.component.html', 'pipes-json')(format=".")
  :marked
    생성된 출력은 다음과 같을 것입니다

    The generated output would look something like this
  code-example(language="json").
    { "firstName": "Hercules", "lastName": "Son of Zeus",
      "birthdate": "1970-02-25T08:00:00.000Z",
      "url": "http://www.imdb.com/title/tt0065832/",
      "rate": 325, "id": 1 }

a(href="#toc") back to top

.l-hr
a#safe-navigation-operator
:marked
  ### 안전 내비게이션 연산자  <span class="syntax">?.</span> ) 와 null 프로퍼티 경로
  ### The safe navigation operator ( <span class="syntax">?.</span> ) and null property paths

  Angular **안전 내비게이션 연산자 (`?.`)**는 프로퍼티 경로에서 null과 undefined 값을 보호하는 강력하고 편리한 방법입니다.
  다음은 `currentHero`가 null인 경우의 뷰 렌더링 실패에 대한 보호입니다.

  The Angular **safe navigation operator (`?.`)** is a fluent and convenient way to guard against null and undefined values in property paths.
  Here it is, protecting against a view render failure if the `currentHero` is null.
+makeExample('template-syntax/ts/src/app/app.component.html', 'safe-2')(format=".")

block dart-safe-nav-op
  //- N/A

:marked
  아래와 같은 데이터 연동 `title` 프로퍼티가 null일 경우 어떻게 될까요?

  What happens when the following data bound `title` property is null?
+makeExample('template-syntax/ts/src/app/app.component.html', 'safe-1')(format=".")
:marked
  뷰는 여전히 렌더링 되지만 표시된 값은 비어있습니다; 오직 "The title is" 만이 보입니다.
  이것은 합리적인 행동입니다. 적어도 앱에 crash가 발생하기 전까지는요.

  The view still renders but the displayed value is blank; you see only "The title is" with nothing after it.
  That is reasonable behavior. At least the app doesn't crash.

  다음 예제처럼 null 히어로의 `firstName`을 표시하는
  템플릿 표현식이 프로퍼티 경로를 포함한 경우를 가정해보겠습니다.

  Suppose the template expression involves a property path, as in this next example
  that displays the `firstName` of a null hero.

code-example(language="html").
  The null hero's name is {{nullHero.firstName}}

block null-deref-example
  :marked
    JavaScript는 null 참조 에러를 던지므로 Angular는 다음처럼 합니다:

    JavaScript throws a null reference error, and so does Angular:
  code-example(format="nocode").
    TypeError: Cannot read property 'firstName' of null in [null].

:marked
  더 나빠졌군요. *전체 뷰가 사라졌습니다*.

  Worse, the *entire view disappears*.

  `hero` 프로퍼티가 절대로 null이 될 수 없다면 이것도 합리적인 행동이라고 주장할 수 있습니다.
  만약 절대로 null이 아니어야 하지만 여전히 null인 경우,
  반드시 잡아서 고쳐야 하는 프로그래밍 에러를 만들게 된 것입니다.
  예외를 던지는 것이 올바른 처리방법입니다.

  This would be reasonable behavior if the `hero` property could never be null.
  If it must never be null and yet it is null,
  that's a programming error that should be caught and fixed.
  Throwing an exception is the right thing to do.

  반면에 특히 데이터가 결국은 도착할 것이라는 것을 알 경우에,
  프로퍼티 경로의 null 값은 때때로 괜찮을 수 있습니다.

  On the other hand, null values in the property path may be OK from time to time,
  especially when the data are null now and will arrive eventually.

  데이터를 기다리는 동안, 뷰는 불평 없이 렌더링해야 하고,
  null 프로퍼티 경로는 `title` 프로퍼티가 했던 것처럼 공란으로 보여야 합니다.

  While waiting for data, the view should render without complaint, and
  the null property path should display as blank just as the `title` property does.

  불행히도 그 앱은 `currentHero`가 null인 경우 crash가 발생합니다.

  Unfortunately, the app crashes when the `currentHero` is null.

  [NgIf](#ngIf)로 이 문제를 해결할 수 있습니다.

  You could code around that problem with [*ngIf](#ngIf).
+makeExample('template-syntax/ts/src/app/app.component.html', 'safe-4')(format=".")

block safe-op-alt
  :marked
    처음 null을 만나게 되면 표현식에서 탈출하는 것을 알고 있으므로, `&&`를 사용한 프로퍼티 경로의 일부를 연결할 수 있습니다,

    You could try to chain parts of the property path with `&&`, knowing that the expression bails out
    when it encounters the first null.
  +makeExample('template-syntax/ts/src/app/app.component.html', 'safe-5')(format=".")

:marked
  이러한 접근법은 장점이 있을 수 있습니다. 특별히 프로퍼티 경로가 긴 경우에.
  `a.b.c.d`와 같은 긴 프로퍼티 패스의 어딘가에서 null 보호를해야 한다고 상상해보세요.

  These approaches have merit but can be cumbersome, especially if the property path is long.
  Imagine guarding against a null somewhere in a long property path such as `a.b.c.d`.

  Angular 안전 내비게이션 연산자 (`?.`)는 프로퍼티 패스에서 null을 보호하는 보다 유창하고 편리한 방법입니다.
  표현식은 처음 null 값을 만나면 탈출합니다.
  공란을 표시하지만 앱은 에러 없이 작동합니다.

  The Angular safe navigation operator (`?.`) is a more fluent and convenient way to guard against nulls in property paths.
  The expression bails out when it hits the first null value.
  The display is blank, but the app keeps rolling without errors.
+makeExample('template-syntax/ts/src/app/app.component.html', 'safe-6')(format=".")
:marked
  `a?.b?.c?.d`와 같은 긴 프로퍼티 경로에 대해서도 완벽히 동작합니다.

  It works perfectly with long property paths such as `a?.b?.c?.d`.

a(href="#toc") back to top
.l-hr
:marked
  ## 요약
  ## Summary

  방금 템플릿 구문의 탐험을 마쳤습니다. 이제 우리 자신만의 컴포넌트나 지시자를 만들 때 지식을 써먹을 때가 왔습니다.

  You've completed this survey of template syntax. Now it's time to put that knowledge to work on your own components and directives.