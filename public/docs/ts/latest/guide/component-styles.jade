block includes
  include ../_util-fns

:marked
  Angular 어플리케이션은 스타일시트로 일반적인 CSS를 이용합니다. 즉 우리가
  CSS 스타일시트에 대해 알고 있는 모든 것, 가령 선택자나 규칙, 미디어쿼리 등을
  Angular 어플리케이션에 직접 사용할 수 있어요.

  그 외에도, Angular는 *컴포넌트 스타일*을 이용하여 일반적인 CSS 보다 더욱 체계적으로
  모듈화를 하여 번들링 할 수 있는 능력이 있습니다.

  이번 챕터에서는 이러한 *컴포넌트 스타일*을 어떻게 사용하고 적용할 수 있는지 배워볼거에요.

  ## 목차

  * [컴포넌트 스타일 사용하기](#using-component-styles)
  * [특별한 선택자](#special-selectors)
  * [컴포넌트에 스타일 불러오기](#loading-styles)
  * [뷰 캡슐화 제어하기: Emulated, Native, and None](#view-encapsulation)
  * [부록 1: 생성된 런타임 컴포넌트 스타일 탐색하기](#inspect-generated-css)
  * [부록 2: 상대 경로 URL을 이용하여 스타일 불러오기](#relative-urls)

  이 페이지의 예제는 <live-example></live-example> 에서 확인 가능합니다.

.l-main-section
:marked
  ## 컴포넌트 스타일 사용하기

  우리가 작성하는 모든 Angular 컴포넌트에 대해, 우리는 HTML 템플릿뿐만 아니라,
  템플릿과 같이 동작하는 CSS 스타일(선택자, 규칙, 미디어 쿼리 등)도 정의합니다.

  이를 하기 위한 방법 중 하나는 컴포넌트 내의 메타데이터에 `styles` 속성 값을 설정하는 것 입니다.
  `styles` 속성 값은 CSS 코드가 포함된 문자열의 배열을 취합니다.
  보통 아래의 예제와 같이 하나의 문자열만을 주지요.

+makeExample('component-styles/ts/src/app/hero-app.component.ts')(format='.')

:marked
  컴포넌트 스타일은 전통적이며, 전역적으로 스타일을 작성하는 방법과 몇 가지가 다릅니다.

  먼저 컴포넌트 스타일 안에 넣는 선택자들은 *오직 해당하는 컴포넌트의 템플릿 안에서만 적용됩니다.* 위의 예제에서의
  `h1` 선택자는 `HeroAppComponent` 템플릿 내의 `<h1>` 태그에만 적용되며, 어플리케이션 내의 그 밖의 `<h1>` 태그에는 영향을 미치지 않습니다.

  이것은 전통적인 CSS가 동작하는 방식에 비하여 모듈화에 있어서 다음과 같은 개선점을 가지고 있습니다.

  1. 각각의 컴포넌트의 상황에 최적화 된 선택자와 클래스 이름을 사용할 수 있다.

  1. 클래스 이름과 선택자들은 해당 컴포넌트에 지역적이며, 어플리케이션 내의 다른 곳에서 사용되고 있는
     다른 클래스들이나 선택자들과 겹치지 않는다.

  1. 컴포넌트의 스타일은 어플리케이션의 다른 곳에서 스타일을 변경함으로써 *변경할 수 없다*.

  1. 각각의 컴포넌트의 CSS 코드는 TypeScript 와 HTML 코드 내에 동시에 적용할 수 있으며,
     이는 프로젝트 구조를 정리하는데에 도움이 된다.

  1. 미래의 어느 시점에 해당 코드가 어디에 또 사용되었는지 찾아보는 고통을 겪지 않고도
     컴포넌트의 CSS 코드를 변경하거나 제거할 수 있다. 그저 컴포넌트 내에 있는 코드만 보면 된다.

a(id="special-selectors")
.l-main-section
:marked
  ## 특별한 선택자들

  컴포넌트 스타일에는 [shadow DOM 스타일의 스코핑](https://www.w3.org/TR/css-scoping-1) 으로부터 파생된 몇몇 특별한 *선택자들*이 있습니다.

  ### :host

  `:host` 가상 클래스 선택자를 해당 컴포넌트의 *상위 컴포넌트*를 선택하기 위해 사용하세요.
  (컴포넌트 템플릿 *내에 존재하는* 엘리먼트를 선택하는 경우와는 반대로 말이에요.)

+makeExample('component-styles/ts/src/app/hero-details.component.css', 'host')(format='.')

:marked
  이 방법은 상위 엘리먼트를 선택할 수 있는 *유일한* 방법입니다. 다른 선택자들로는
  상위 엘리먼트에 절대 선택할 수 없어요, 왜냐면 그 엘리먼트는 컴포넌트의 템플릿에 속하지 않았으니까요.
  그 엘리먼트는 해당 엘리먼트의 상위 컴포넌트의 템플릿에 속해있지요.

  `:host` 다음에 오는 소괄호에 다른 선택자를 포함하여, *함수의 형태*를 사용하여
  조건에 따라 상위 엘리먼트의 스타일을 적용하세요.

  다음의 예제는 `active` 클래스를 가지고 있는 경우에 상위 엘리먼트를 선택할 것입니다.

+makeExample('component-styles/ts/src/app/hero-details.component.css', 'hostfunction')(format=".")

:marked
  ### :host-context

  때때로 컴포넌트의 뷰의 *외부*에서 어떤 조건에 따라 스타일을 적용하는 것이 좋을 때가 있습니다.
  예를 들어, 문서의 `<body>` 엘리먼트에 적용되는 CSS 테마 클래스가 있을 수 있죠. 이 테마를 기반으로
  우리의 컴포넌트도 맞춰서 변경하고 싶다고 해봐요.

  `:host-context()` 가상 선택자를 사용하세요. 이 선택자는 `:host()` 함수처럼 동작합니다.
  이 선택자는 해당 컴포넌트의 *모든 부모* 엘리먼트들의 CSS 클래스를 찾아냅니다.
  문서의 최상위 엘리먼트인 `<html>` 엘리먼트까지요. 이것은 다른 선택자들과 조합하였을 때 굉장히 유용합니다.

  다음의 예제는, 어떠한 부모 엘리먼트가 `theme-light` 이라는 CSS 클래스를 가지고 있는 경우에 대해,
  컴포넌트 내의 `<h2>` 엘리먼트에 `background-color` 스타일을 적용합니다.

+makeExample('component-styles/ts/src/app/hero-details.component.css', 'hostcontext')(format='.')

:marked
  ### /deep/

  컴포넌트 스타일은 일반적으로 컴포넌트의 템플릿 내에 존재하는 HTML에 대해서만 적용됩니다.

  `/deep/` 선택자를 이용하여 모든 자식 컴포넌트 뷰에 대해 스타일을 전부 적용시키도록 강제할 수 있습니다.
  `/deep/` 선택자는 컴포넌트가 어떠한 깊이에 있든, 얼마나 많이 겹쳐 있든 상관없이 적용되며, 컴포넌트의
  *View Children과 Content Children 모두*에 적용됩니다.

  다음의 예제는, 상위 엘리먼트부터 해당 컴포넌트에 이르기까지 DOM 내의 모든 자식 엘리먼트에 대해
  `<h3>` 엘리먼트를 선택합니다.
+makeExample('component-styles/ts/src/app/hero-details.component.css', 'deep')(format=".")

:marked
  `/deep/` 선택자는 별칭으로 `>>>` 를 가지고 있습니다. 두 가지를 마음껏 바꾸어 사용할 수 있습니다.

.alert.is-important
  :marked
    `/deep/`과 `>>>` 선택자는 **emulated** 뷰 캡슐화에 대해서만 사용되어야 합니다.
    이것은 기본 값이며, 대개 그렇게 사용합니다. 자세한 내용에 대해서는 [뷰 캡슐화 제어](#view-encapsulation) 부분을 참조하세요.

a(id='loading-styles')
.l-main-section
:marked
  ## 컴포넌트로 스타일 불러오기

  컴포넌트에 스타일을 더하는 여러 가지 방법이 있습니다.
  * 템플릿 HTML에 인라인 `<style>` 태그 사용
  * 메타 정보로 `styles` 이나 `styleUrls`를 설정
  * CSS 의 `@import` 사용

  위에서 언급한 스코핑 규칙은 이 불러오는 방법들에 대해 각각 적용됩니다.

  ### 메타 정보에 styles 설정

  컴포넌트의 `@Component` 장식자에 `styles` 배열 속성 값을 추가할 수 있습니다.
  배열 내의 각각의 문자열에(일반적으로는 하나의 문자열만 사용합니다) CSS를 정의합니다.

+makeExample('component-styles/ts/src/app/hero-app.component.ts')

:marked
  ### 템플릿에 인라인 `<style>` 태그 사용

  `<style>` 태그를 이용하여 HTML 템플릿 내에 직접 사용함으로써
  스타일을 적용시킬 수도 있습니다.

+makeExample('component-styles/ts/src/app/hero-controls.component.ts', 'inlinestyles')

:marked
  ### 메타 정보에 style URLs 설정

  컴포넌트의 `@Component` 장식자에 `styleUrls` 속성값을 주어 외부의 CSS 파일들을 불러올 수 있습니다.

+makeExample('component-styles/ts/src/app/hero-details.component.ts', 'styleurls')

block style-url
  .alert.is-important
    :marked
      이 URL은 ***어플리케이션의 루트 경로에 상대적*** 이며, 루트 경로는 일반적으로
      어플리케이션을 관장하는 `index.html`의 경로를 의미합니다.
      스타일시트 파일의 URL은 컴포넌트 파일에 대해 상대적이지 *않습니다*.
      그것이 예제에서 본 URL이 `src/app/`으로 시작하는 이유입니다.
      [부록 2](#relative-urls)에서 URL을 컴포넌트 파일의 상대 경로에 맞게 설정하는
      방법을 살펴보세요.

block module-bundlers
  .l-sub-section
    :marked
      Webpack과 같은 모듈 번들러를 사용하는 사용자들은 `styles` 속성을 이용하여
      빌드 타임에 외부 CSS 파일들을 불러들일 수 있습니다. 이렇게 작성할 수 있습니다:

      `styles: [require('my.component.css')]`

      `stylesUrls` 속성이 **아닌**, `styles` 속성을 설정하였습니다! 모듈 번들러는
      CSS 문자열을 로딩하지, Angular를 로딩하지 않습니다.
      Angular는 모듈 번들러가 CSS 파일들을 불러들인 이후에, 오직 CSS 문자열만 볼 뿐입니다.
      Angular에게는 마치 우리가 `styles` 배열에 손으로 직접 CSS 문자열을 작성한 것처럼
      보일 뿐 입니다.
      CSS를 이러한 방식으로 로딩하는 방식에 대해서는, 모듈 번들러의 문서를 참조하세요.

:marked
  ### 템플릿에 link 태그

  컴포넌트의 HTML 템플릿 내에 `<link>` 태그를 직접 이용할 수도 있습니다.

  `styleUrls`과 같이, link 태그의 `href` URL은 컴포넌트 파일에 대해 상대적인 것이 아니라,
  어플리케이션 루트 경로에 대해 상대적입니다.

+makeExample('component-styles/ts/src/app/hero-team.component.ts', 'stylelink')

:marked
  ### CSS @import

  표준 CSS의 [`@import` 규칙](https://developer.mozilla.org/en/docs/Web/CSS/@import) 을
  이용하여 CSS 파일들을 불러들일 수도 있습니다.


block css-import-url
  :marked
    *이 경우*, URL은 불러들여 오는 CSS의 파일에 대해 상대적입니다.

+makeExample('component-styles/ts/src/app/hero-details.component.css', 'import', 'src/app/hero-details.component.css (excerpt)')

a#view-encapsulation
.l-main-section
:marked
  ## 뷰 캡슐화 제어: Native, Emulated, and None

  위에서 논의되었듯, 컴포넌트의 CSS 스타일은 컴포넌트 자체 뷰에 캡슐화되며, 어플리케이션의 다른 부분에
  영향을 끼치지 않습니다.

  이러한 캡슐화를 *컴포넌트 별* 기반으로 *뷰 캡슐화 모드* 값을 컴포넌트 메타정보에 설정함으로써 이러한
  동작들을 제어할 수 있습니다. 선택할 수 있는 3가지의 모드는 다음과 같습니다:

  * `Native` 뷰 캡슐화는 브라우저의 네이티브 [Shadow DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
    구현체를 사용하여 컴포넌트의 상위 엘리먼트에 Shadow DOM을 붙히고, Shadow DOM 내에 컴포넌트의 뷰를 놓습니다.
    컴포넌트의 스타일은 그 Shadow DOM 내에 포함됩니다.

  * `Emulated` 뷰 캡슐화는 (**기본 값**) CSS 코드를 효율적으로 컴포넌트의 뷰에 CSS를 스코핑하여
    Shadow DOM의 행동을 모방합니다.
    자세한 내용은 [부록 1](#inspect-generated-css) 을 참고하세요.

  * `None` 은 Angular가 뷰 캡슐화를 하지 않음을 의미합니다.
    Angular는 CSS를 전역 스타일에 더할 것입니다. 기존에 논의되었던 스코핑 규칙, 고립화 등이 적용되지 않을 것입니다.
    이 방법은 본질적으로는 컴포넌트의 스타일을 HTML에 붙여넣기 한 것과 동일합니다.

  컴포넌트의 캡슐화 모드를 컴포넌트의 메타 정보에 `encapsulation` 속성을 이용하여 설정하세요:

+makeExample('component-styles/ts/src/app/quest-summary.component.ts', 'encapsulation.native')(format='.')

:marked
  `Native` 뷰 캡슐화는 [네이티브로 Shadow DOM을 지원하는 브라우저에 대해서만](http://caniuse.com/#feat=shadowdom) 동작합니다.
  (역자 주: 네이티브로 지원한다는 의미는, 폴리필 등을 이용하지 않고도 동작하는, 최신 브라우저를 의미합니다.)
  지원 여부는 아직까지도 제한적이므로, `Emulated` 뷰 캡슐화가 기본 모드이며 대개의 경우에 추천되는 이유가
  바로 이것이지요.

a#inspect-generated-css
.l-main-section
:marked
  ## 부록 1: Emulated 뷰 캡슐화에 대해 생성된 CSS 코드 검사(inspect)하기

  기본 emulated 뷰 캡슐화를 사용하는 경우, Angular는 모든 컴포넌트의 스타일을 미리 처리하여서
  표준 Shadow CSS의 스코핑 룰에 대략적으로 비슷하게 할 수 있습니다.

  실행 중인 Angular 어플리케이션의 emulated 뷰 캡슐화 된 DOM 을 검사할 때는,
  각각의 DOM 엘리먼트에 몇 가지 추가된 속성들을 볼 수 있습니다:

code-example(format="").
  &lt;hero-details _nghost-pmm-5>
    &lt;h2 _ngcontent-pmm-5>Mister Fantastic&lt;/h2>
    &lt;hero-team _ngcontent-pmm-5 _nghost-pmm-6>
      &lt;h3 _ngcontent-pmm-6>Team&lt;/h3>
    &lt;/hero-team>
  &lt;/hero-detail>

:marked
  두 가지 종류의 생성된 속성이 있습니다:
  * 네이티브 캡슐화에서 Shadow DOM 의 상위 엘리먼트가 될 엘리먼트는 `_nghost` 라는, 생성된 속성값을
    가지고 있습니다. 이 값은 컴포넌트의 상위 엘리먼트들의 경우에 생성됩니다.
  * 컴포넌트 뷰 내의 엘리먼트는 `_ngcontent` 속성값을 갖습니다. 이 속성값은
    이 엘리먼트가 어떠한 상위 엘리먼트의 emulated Shadow DOM에 속해있는지를 식별합니다.

  이 속성들의 정확한 값은 중요하지 않습니다. 이 값들은 자동으로 생성되며, 어플리케이션 코드에서는
  절대 참조하지 않습니다. 하지만 이 값들은 생성된 컴포넌트의 스타일을 가리키며, 이 스타일은
  DOM의 `<head>` 부분에서 찾아볼 수 있지요:

code-example(format="").
  [_nghost-pmm-5] {
    display: block;
    border: 1px solid black;
  }

  h3[_ngcontent-pmm-6] {
    background-color: white;
    border: 1px solid #777;
  }

:marked
  이것들은 우리가 작성한 스타일이며, 각각의 선택자에 `_nghost`나 `_ngcontent` 의 속성 선택자가
  추가되어 후처리 되었습니다. 이렇게 추가된 선택자들은 이번 가이드에서 설명된 스코핑 규칙을 적용시킵니다.

  아마 Shadow DOM이 더욱 사용되기 전까지는 *emulated* 모드와 함께 살아야 할 것입니다.

a#relative-urls
.l-main-section
:marked
  ## 부록 2: 상대 경로 URL을 이용하여 스타일 불러오기

  같은 디렉토리 내에 컴포넌트의 코드, HTML, CSS 세 개의 별도의 파일로 분리하는 것은 일반적인 관습입니다:
code-example(format="nocode").
  quest-summary.component.ts
  quest-summary.component.html
  quest-summary.component.css

:marked
  컴포넌트의 메타정보에 `templateUrl`, `styleUrls` 속성을 설정하여 템플릿과 CSS 파일을 포함시킬 수 있습니다.
  대개 이 파일들이 컴포넌트와 같이 위치하고 있기 때문에, 절대 경로를 이용하여 지정해 줄 필요 없이 그저 이름만으로
  참조하는 것도 괜찮을 것입니다.

block module-id
  :marked
    Angular가 전체 경로 URL을 계산하는 방법을 컴포넌트의 메타정보에 `moduleId` 속성값을 `module.id`로 줌으로써
    변경할 수도 있습니다.

  +makeExample('src/app/quest-summary.component.ts')

  :marked
    `moduleId`에 대해서는 [컴포넌트-상대 경로](../cookbook/component-relative-paths.html) 챕터에서
    더욱 자세한 정보를 알아보세요.
