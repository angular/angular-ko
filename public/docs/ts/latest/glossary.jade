block includes
  include _util-fns

//- current.path = ['docs', lang, 'latest', ...]
- var lang = current.path[1]
- var docsPath='/' + current.path[0]
- var docsLatest='/' + current.path.slice(0,3).join('/');
- var _at = lang === 'js' ? '' : '@'
- var _decoratorLink = '<a href="#' + _decorator + '">' + _decorator + '</a>'

:marked
  Angular에는 Angular만의 용어들이 있습니다.
  대부분의 용어는 일상적인 영어 단어들로 이루어져 있지만
  Angular 시스템 안에서 특정한 의미를 가집니다.

  Angular has a vocabulary of its own.
  Most Angular terms are everyday English words
  with a specific meaning within the Angular system.

  이 용어해설 목록은 가장 주요하게 쓰이는 용어들과
  특이하거나 예상 밖의 정의를 가지고 있어
  친숙하지 않은 몇몇 용어들을 정리해 두었습니다.

  This glossary lists the most prominent terms
  and a few less familiar ones that have unusual or
  unexpected definitions.

  [A](#A) [B](#B) [C](#C) [D](#D) [E](#E) [F](#F) [G](#G) [H](#H) [I](#I)
  [J](#J) [K](#K) [L](#L) [M](#M) [N](#N) [O](#O) [P](#P) [Q](#Q) [R](#R)
  [S](#S) [T](#T) [U](#U) [V](#V) [W](#W) [X](#X) [Y](#Y) [Z](#Z)

.l-main-section#A

a#aot
:marked
  ## Ahead-of-time (AOT) 컴파일
  ## Ahead-of-time (AOT) compilation
.l-sub-section
  :marked
    Angular 애플리케이션은 개발자가 빌드할 때 미리 컴파일할 수 있습니다.
    커맨드라인 compiler인 `ngc`를 사용해 애플리케이션을 컴파일하면 모듈 팩토리(Module Factory)에 바로 실행(bootstrap) 할 수 있습니다.
    이 말은 곧 JavaScript 번들파일에 Angular 컴파일러를 포함할 필요가 없다는 의미입니다.
    Ahead of Time 컴파일을 적용한 애플리케이션은 로드 시간 절감과 퍼포먼스 향상의 효과를 누릴 수 있습니다.

    You can compile Angular applications at build-time.
    By compiling your application<span if-docs="ts"> using the compiler-cli, `ngc`</span>, you can bootstrap directly
    to a module factory, meaning you don't need to include the Angular compiler in your JavaScript bundle.
    Ahead-of-time compiled applications also benefit from decreased load time and increased performance.

+ifDocsFor('ts')
  :marked
    ## Angular 모듈
    ## Angular module
  .l-sub-section
    :marked
      애플리케이션을 기능 단위의 결합 가능한 블록들로 구조화할 수 있게 도와줍니다.
      Angular 모듈은 애플리케이션에서 쓰이는 컴포넌트, 지시자, 파이프와 함께,
      애플리케이션에 필요한 외부 앵귤러 모듈 리스트(`FormsModule`과 같은)를 찾고 확인합니다.

      Helps you organize an application into cohesive blocks of functionality.
      An Angular module identifies the components, directives, and pipes that the application uses along with the list of external Angular modules that the application needs, such as `FormsModule`.

      모든 Angular 애플리케이션은 루트 모듈 클래스를 가집니다. 관례상 이 클래스에는 `AppModule`이라는 이름을 붙이고
      `app.module.ts`라는 이름의 파일 안에 만듭니다.

      Every Angular application has an application root module class. By convention, the class is
      called `AppModule` and resides in a file named `app.module.ts`.

      자세한 내용과 예시는 [Angular Module](!{docsLatest}/guide/ngmodule.html)페이지에서 볼 수 있습니다.

      For details and examples, see the [Angular Module](!{docsLatest}/guide/ngmodule.html) page.

+ifDocsFor('ts|dart')
  :marked
    ## 어노테이션 (Annotation)
    ## Annotation
  .l-sub-section
    block annotation-defn
      :marked
        사실상 [데코레이션](#decorator)과 동의어입니다.

        In practice, a synonym for Decoration.

a#attribute-directive
a#attribute-directives
:marked
  ## 속성 지시자 (Attribute Directive)
  ## Attribute directives

.l-sub-section
  :marked
    다른 HTML 엘리먼트, 속성, 프로퍼티와 컴포넌트들의 행동을 탐지하고 변경할 수 있는
    [지시자(Directive)](#directive)의 카테고리입니다.
    보통 HTML 속성으로 표현하기 때문에 이런 이름을 갖게 되었습니다.

    A category of [directive](#directive) that can listen to and modify the behavior of
    other HTML elements, attributes, properties, and components. They are usually represented
    as HTML attributes, hence the name.

    CSS 클래스명을 추가 또는 제거하는 `ngClass` 지시자가 속성 지시자의 좋은 예시입니다.

    A good example of an attribute directive is the `ngClass` directive for adding and removing CSS class names.

    [_속성 지시자(Attribute Directives)_](!{docsLatest}/guide/attribute-directives.html) 가이드에서 자세히 알아보세요.

    Learn about them in the [_Attribute Directives_](!{docsLatest}/guide/attribute-directives.html) guide.

.l-main-section#B

+ifDocsFor('ts|js')
  :marked
    ## 배럴 (Barrel)
    ## Barrel
  .l-sub-section
    :marked
      배럴은 ES2015 모듈 여러 개를 말아서 하나의 편리한 ES2015 모듈로 만드는 방법입니다.
      배럴 자체도 다른 선택된 ES2015 모듈들을 다시 export 하는 ES2015 모듈입니다.

      A barrel is a way to *rollup exports* from several ES2015 modules into a single convenient ES2015 module.
      The barrel itself is an ES2015 module file that re-exports *selected* exports of other ES2015 modules.

      `heroes` 폴더에 세 개의 ES2015 모듈이 있다고 가정해 봅시다:

      Imagine three ES2015 modules in a `heroes` folder:
    code-example.
      // heroes/hero.component.ts
      export class HeroComponent {}

      // heroes/hero.model.ts
      export class Hero {}

      // heroes/hero.service.ts
      export class HeroService {}
    :marked
      배럴이 없다면 세 개의 import 문이 필요할 것입니다.
      
      Without a barrel, a consumer would need three import statements:
    code-example.
      import { HeroComponent } from '../heroes/hero.component.ts';
      import { Hero }          from '../heroes/hero.model.ts';
      import { HeroService }   from '../heroes/hero.service.ts';
    :marked
      대신, `heroes` 폴더에 위 아이템들을 모두 export 하는 배럴을 하나 추가할 수 있습니다. (보통 `index`라고 부릅니다.)
      
      You can add a barrel to the `heroes` folder (called `index`, by convention) that exports all of these items:

    code-example.
      export * from './hero.model.ts';   // re-export all of its exports
      export * from './hero.service.ts'; // re-export all of its exports
      export { HeroComponent } from './hero.component.ts'; // re-export the named thing
    :marked
      이제 필요한 것은 배럴에서 import 할 수 있습니다.
      
      Now a consumer can import what it needs from the barrel.
    code-example.
      import { Hero, HeroService } from '../heroes'; // index is implied
    :marked
      Angular [scoped packages](#scoped-package)는 각각 `index`라는 배럴을 가지고 있습니다.
      
      The Angular scoped packages each have a barrel named `index`.

    .alert.is-important
      :marked
        [Angular module](#angular-module)을 사용할 때도 같은 방법을 쓸 수 있습니다.

        Note that you can often achieve this using [Angular modules](#angular-module) instead.
        
:marked
  ## 바인딩 (Binding)
  ## Binding
.l-sub-section
  :marked
    거의 모든 경우에 [Data-Binding](#data-binding),
    즉 HTML 오브젝트 프로퍼티를 데이터 오브젝트 프로퍼티에 바인딩하는 것을 의미합니다.
    
    Almost always refers to Data Binding and the act of
    binding an HTML object property to a data object property.

    [의존관계 주입](#dependency-injection) 시 "토큰" 또는 "키"와
    의존성 [제공자(provider)](#provider) 사이의 바인딩을 뜻할 때도 있습니다.
    이런 드문 경우에는 의미하는 바가 맥락에 확실히 드러나야 합니다.
    
    May refer to a Dependency Injection binding
    between a "token" or "key" and a dependency provider.
    This more rare usage should be clear in context.

:marked
  ## 실행(Bootstrap)
  ## Bootstrap
.l-sub-section
  block bootstrap-defn-top
    :marked
      Angular 애플리케이션은 루트 Angular 모듈(`AppModule`)을 사용하는 "실행(bootstrap)"을 통해 실행됩니다.
      실행(bootstrap)은 애플리케이션에서 가장 처음으로 로드되는 최상위 레벨 "루트" [컴포넌트](#component)를 정의합니다.
      더 자세한 내용은 [Setup](!{docsLatest}/guide/setup.html)에서 확인하세요.

      You launch an Angular application by "bootstrapping" it using the application root Angular module (`AppModule`). Bootstrapping identifies an application's top level "root" [component](#component), which is the first component that is loaded for the application. 
      For more information, see the [Setup](!{docsLatest}/guide/setup.html) page.
  :marked
    `index.html`에서 각각의 최상위 루트 컴포넌트를 가진 여러 개의 앱을 실행(bootstrap)할 수도 있습니다.

    You can bootstrap multiple apps in the same `index.html`, each with its own top level root.

.l-main-section#C
:marked
  ## 카멜표기법 (camelCase)
  ## camelCase
.l-sub-section
  :marked
    합성어나 합성구를 작성할 때 _첫 단어의 첫 번째 문자를 제외하고_ 각 단어 또는 약어의 첫 문자를 대문자로 표기하는 방법입니다.
    
    The practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter
    _except the first letter, which is lowercase_.

    함수, 프로퍼티, 그리고 메소드 이름에는 통상적으로 카멜표기법을 사용합니다. `square`, `firstName` 그리고 `getHeroes`와 같은 예를 들 수 있겠네요. `square`는 어떻게 단일단어를 카멜표기법으로 작성하는지 보여주는 예시입니다.
    
    Function, property, and method names are typically spelled in camelCase. Examples include: `square`, `firstName` and `getHeroes`. Notice that `square` is an example of how you write a single word in camelCase.

    이 표기법은 또한 **lower 카멜표기법**이라 하여 흔히 [PascalCase](#pascalcase)라고 하는 **upper 카멜표기법**과 구분하기도 합니다.
    Angular 문서에서 "카멜표기법"은 항상 *lower 카멜표기법*을 뜻합니다.
    
    This form is also known as **lower camel case**, to distinguish it from **upper camel case**, which is [PascalCase](#pascalcase).
    When you see "camelCase" in this documentation it always means *lower camel case*.

a#component
:marked
  ## 컴포넌트 (Component)
  ## Component
.l-sub-section
  :marked
    [뷰](#view)에 데이터를 노출하고, 뷰의 화면과 사용자 인터랙션 로직의 대부분을 처리하는 Angular 클래스.

    An Angular class responsible for exposing data to a [view](#view) and handling most of the view’s display and user-interaction logic.

    컴포넌트는 Angular 시스템에서 가장 중요한 구성요소 중 하나입니다.
    사실 컴포넌트는 [템플릿](#template)을 동반한 Angular [지시자](#directive)입니다.
    
    The *component* is one of the most important building blocks in the Angular system.
    It is, in fact, an Angular [directive](#directive) with a companion [template](#template).

    `!{_at}Component` [데코레이터](#decorator)를 컴포넌트 클래스에 적용함으로써
    Angular가 컴포넌트 인스턴스를 만들어서 템플릿과 함께 뷰로 렌더링하는 데에
    필수적인 컴포넌트 메타데이터를 클래스에 알려줄 수 있습니다.

    You apply the `!{_at}Component` !{_decoratorLink} to
    the component class, thereby attaching to the class the essential component metadata
    that Angular needs to create a component instance and render it with its template
    as a view.

    "MVC"와 "MVVM" 패턴에 친숙한 경우,
    컴포넌트가 "컨트롤러" 또는 "뷰 모델"의 역할을 한다고 생각하시면 됩니다.
    
    Those familiar with "MVC" and "MVVM" patterns will recognize
    the component in the role of "controller" or "view model".

.l-main-section#D
:marked
  ## 대시표기법 (dash-case)
  ## dash-case
.l-sub-section
  :marked
    합성어나 합성구를 작성할 때 각 단어를 대시 또는 하이픈(`-`)으로 구분하는 표기법입니다.
    이 방법은 [케밥표기법](#kebab-case)이라고도 합니다.
    
    The practice of writing compound words or phrases such that each word is separated by a dash or hyphen (`-`).
    This form is also known as kebab-case.

    `my-app`과 같은 [지시자](#directive) 셀렉터들<span if-docs="ts">과
    `hero-list.component.ts`와 같은 파일명 루트들</span>은 보통 대시표기법으로 작성합니다.
    
    Directive selectors (like `my-app`) <span if-docs="ts">and
    the root of filenames (such as `hero-list.component.ts`)</span> are often
    spelled in dash-case.

:marked
  ## Data Binding
  ## Data Binding
.l-sub-section
  :marked
    애플리케이션은 사용자에게 데이터 값을 보여주고, 사용자의 액션(클릭, 터치, 키스트로크)에 반응합니다.
    
    Applications display data values to a user and respond to user
    actions (clicks, touches, keystrokes).

    HTML의 애플리케이션 데이터 값을 수동으로 넣거나, 이벤트 리스너를 첨부하거나, 화면에서 변경된 값을 가져오거나, 애플리케이션 데이터 값d 업데이트하는 대신에, HTML 위젯과 데이터 소스 사이의 관계를 선언함으로써 데이터 바인딩을 이용하고, 프레임워크가 세부사항을 처리하게 합니다.

    Instead of manually pushing application data values into HTML, attaching
    event listeners, pulling changed values from the screen, and
    updating application data values, you can use data binding by declaring the relationship between an HTML widget and data source and let the
    framework handle the details.

    Angular는 다양한 데이터 바인딩 작업과 선언 구문을 지원하는 데이터 바인딩이 풍부한 프레임워크입니다.

    Angular has a rich data binding framework with a variety of data binding
    operations and supporting declaration syntax.

     바인딩 형태에 대해서는 [Template Syntax](!{docsLatest}/guide/template-syntax.html)페이지에서 확인하세요:
     
     Read about the forms of binding in the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page:
     
     * [Interpolation](!{docsLatest}/guide/template-syntax.html#interpolation).
     * [Interpolation](!{docsLatest}/guide/template-syntax.html#interpolation).
     * [Property binding](!{docsLatest}/guide/template-syntax.html#property-binding).
     * [Property binding](!{docsLatest}/guide/template-syntax.html#property-binding).
     * [Event binding](!{docsLatest}/guide/template-syntax.html#event-binding).
     * [Event binding](!{docsLatest}/guide/template-syntax.html#event-binding).
     * [Attribute binding](!{docsLatest}/guide/template-syntax.html#attribute-binding).
     * [Attribute binding](!{docsLatest}/guide/template-syntax.html#attribute-binding).
     * [Class binding](!{docsLatest}/guide/template-syntax.html#class-binding).
     * [Class binding](!{docsLatest}/guide/template-syntax.html#class-binding).
     * [Style binding](!{docsLatest}/guide/template-syntax.html#style-binding).
     * [Style binding](!{docsLatest}/guide/template-syntax.html#style-binding).
     * [Two-way data binding with ngModel](!{docsLatest}/guide/template-syntax.html#ngModel).
     * [Two-way data binding with ngModel](!{docsLatest}/guide/template-syntax.html#ngModel).

+ifDocsFor('ts|dart')
  a#decorator
  a#decoration
  :marked
    ## 데코레이터 (Decorator) |  데코레이션 (Decoration)
    ## Decorator | decoration
  .l-sub-section
    block decorator-defn
      :marked
        데코레이터는 클래스와 그에 속한 프로퍼티와 메소드, 그리고 함수 인자들에 메타데이터를 적용하는 **함수**입니다.

        A decorator is a **function** that adds metadata to a class, its members (properties, methods) and function arguments.

        데코레이터는 타입스크립트에 포함되어 있고 ES2016 (AKA ES7)에 제안된 JavaScript [기능](https://github.com/wycats/javascript-decorators)입니다.
        
        Decorators are a JavaScript language feature, implemented in TypeScript and proposed for ES2016 (AKA ES7).

        Angular에서는 데코레이터를 적용하기 위에 적용대상의 바로 왼편 또는 윗편에 둡니다.

        To apply a decorator, position it immediately above or to the left of the thing it decorates.

        Angular에는 애플리케이션 파트와 상호작동하도록 도와주는 자체적인 데코레이터 세트가 있습니다.
        다음은 클래스를 Angular [컴포넌트](#component)로 정의하는 `@Component` 데코레이터와
        해당 컴포넌트의 `name`프로퍼티에 적용된 `@Input` 데코레이터의 예시입니다.
        여기서 생략된 `@Component`의 오브젝트 인자는 본래 적절한 컴포넌트 메타데이터를 가집니다.

        Angular has its own set of decorators to help it interoperate with your application parts.
        Here is an example of a `@Component` decorator that identifies a
        class as an Angular [component](#component) and an `@Input` decorator applied to the `name` property
        of that component. The elided object argument to the `@Component` decorator would contain the pertinent component metadata.

        ```
        @Component({...})
        export class AppComponent {
          constructor(@Inject('SpecialFoo') public foo:Foo) {}
          @Input() name:string;
        }
        ```

        데코레이터의 범위는 데코레이트하는 언어의 기능으로 제한됩니다. 
        여기에 보여진 데코레이션 중 어느 것도 파일에 보여지는 다른 클래스로 누출되지 않습니다.
        
        The scope of a decorator is limited to the language feature
        that it decorates. None of the decorations shown here will "leak" to other
        classes appearing below it in the file.

      .alert.is-important
        :marked
          데코레이터를 적용할 때, 항상 괄호 `()`를 포함하세요.

          Always include parentheses `()` when applying a decorator.

:marked
  ## 의존관계 주입 (Dependency Injection)
  ## Dependency injection
.l-sub-section
  :marked
    의존관계 주입은 디자인 패턴인 동시에
    애플리케이션의 한 부분을 만들고 이를 요청하는 다른 부분에 전달하는 메커니즘입니다.
    
    Dependency injection is both a design pattern and a mechanism
    for creating and delivering parts of an application to other
    parts of an application that request them.

    Angular 애플리케이션을 작성할 때에는 각각 하나의 일을 담당하는 단순한 요소들을 여러 개 정의하고
    애플리케이션을 실행할 때 그것들을 한 데 묶는 것을 권장합니다.
    
    Angular developers prefer to build applications by defining many simple parts
    that each do one thing well and then wiring them together at runtime.

    각 요소들은 보통 다른 요소들을 사용합니다.
    Angular [컴포넌트](#component)가 데이터를 받아오거나 연산을 수행하는데에 서비스 요소의 도움이 필요할 수도 있습니다.
    "A" 요소가 다른 "B" 요소를 필요로 할 때, "A"가 "B"에 의존하고 "B"는 "A"의 부양자라고 합니다.

    These parts often rely on other parts. An Angular [component](#component)
    part might rely on a service part to get data or perform a calculation. When
    part "A" relies on another part "B", you say that "A" depends on "B" and
    that "B" is a dependency of "A".

    "A"를 만들고 모든 의존관계를 처리하는 데에 "의존관계 주입 시스템"을 사용할 수 있습니다.
    "A"가 "B"를 필요로 하고 "B"는 "C"에 의존할 경우 이 시스템이 의존관계 체인을 해결하고
    완벽하게 준비된 "A"의 인스턴스를 반환하도록 하는 거죠.
    
    You can ask a "dependency injection system" to create "A"
    and it will handle all of "A"s dependencies.
    If "A" needs "B" and "B" needs "C", the system resolves that chain of dependencies
    and returns a fully prepared instance of "A".

    Angular는 정교한 [의존관계 주입(Dependency Injection)](dependency-injection.html) 시스템을 제공합니다.
    이 시스템은 애플리케이션 요소를 적재적소에 "주입"하여 애플리케이션을 한 데 모으고 실행합니다.
    
    Angular provides and relies upon its own sophisticated
    [dependency injection](!{docsLatest}/guide/dependency-injection.html) system
    to assemble and run applications by "injecting" application parts
    into other application parts where and when needed.

    코어에는 요청시 의존관계(부양자 값)을 반환하는 [`Injector`](#injector)가 있습니다.
    `injector.get(token)`과 같은 표현은 주어진 token과 관련된 값들을 반환합니다.
    
    At the core there is an [`injector`](#injector) that returns dependency values on request.
    The expression `injector.get(token)` returns the value associated with the given token.
    
    토큰은 Angular 타입(`OpaqueToken`)입니다. 우리는 가끔 토근을 직접적으로 다루게 됩니다. 
    대부분 클래스 이름(`Foo`)나 문자열("foo")로 사용하게 되며, Angular는 그것을 토큰으로 변환합니다.
    `injector.get(Foo)`을 사용할 때, 일반적으로 주입자(Injector)는 클래스`Foo`의 값 대신 `Foo`의 토큰과 관련된 인스턴스를 반환합니다.

    A token is an Angular type (`OpaqueToken`). You rarely deal with tokens directly; most
    methods accept a class name (`Foo`) or a string ("foo") and Angular converts it
    to a token. When you write `injector.get(Foo)`, the injector returns
    the value associated with the token for the `Foo` class, typically an instance of `Foo` itself.

    많은 동작 중에, Angular는 표시할 [`컴포넌트`](#component)를 만들 때와 같이 유사한 요청들을 내부적으로 처리합니다.
    During many of its operations, Angular makes similar requests internally, such as when it creates a [`component`](#component) for display.

    During many of its operations, Angular makes similar requests internally, such as when it creates a [`component`](#component) for display.

    `Injector`는 토큰의 내부 구조를 부앙자 값(dependency value)으로 유지합니다.
    만약 `Injector`가 토큰에 맞는 값을 찾지 못한다면, `Provider`를 이용하여 토큰에 맞는 새로운 값을 생성합니다.

    The `Injector` maintains an internal map of tokens to dependency values.
    If the `Injector` can't find a value for a given token, it creates
    a new value using a `Provider` for that token.

    [Provider](#provider)는 특정 토큰과 관련된 부양자 값(dependency value)의 새로운 인스턴스를 만들기 위한 방법입니다.

    A [provider](#provider) is a recipe for
    creating new instances of a dependency value associated with a particular token.

    내부 Provider 목록에 해당 토큰에 대한 `Provider`가 있어야만, Injector가 주어진 토큰에 대한 값을 생성할 수 있습니다.
    Provider 등록은 매우 중요한 준비 단계입니다.

    An injector can only create a value for a given token if it has
    a `provider` for that token in its internal provider registry.
    Registering providers is a critical preparatory step.

    Angular는 모든 Injector와 자신의 Provider 일부를 등록합니다.
    우리는 우리 자신의 Provider를 등록할 수 있습니다.

    Angular registers some of its own providers with every injector.
    You can register your own providers.

    더 자세한 내용은 [Dependency Injection](!{docsLatest}/guide/dependency-injection.html)페이지에서 확인해보세요.

    Read more in the [Dependency Injection](!{docsLatest}/guide/dependency-injection.html) page.

a#directive
a#directives
:marked
  ## 지시자 (Directive)
  ## Directive
.l-sub-section
  :marked
    브라우저 DOM에서 HTML 엘리먼트를 생성하고, 고치고, 이들과 상호작용하는 Angular 클래스입니다.
    지시자는 Angular의 가장 핵심적인 기능입니다.
    
    An Angular class responsible for creating, re-shaping, and interacting with HTML elements
    in the browser DOM. Directives are Angular's most fundamental feature.

    지시자는 거의 항상 HTML 엘리먼트 또는 속성과 연동됩니다.
    Angular가 HTML 템플릿에서 지시자를 찾으면 그에 일치하는 지시자 클래스의 인스턴스를 만들고
    그 인스턴스에 브라우저 DOM 중 해당하는 부분의 컨트롤을 넘겨줍니다.
    
    A directive is almost always associated with an HTML element or attribute.
    When Angular finds a directive in an HTML template,
    it creates the matching directive class instance
    and gives the instance control over that portion of the browser DOM.

    `<my-directive>`와 같이 커스텀 지시자와 연동하는 커스텀 HTML 마크업을 만들 수도 있습니다.
    네이티브 HTML을 작성하는 것과 같이 커스텀 마크업을 HTML 템플릿에 추가하면 됩니다.
    이 경우, 지시자가 HTML 자체를 확장한 것이 됩니다.
    
    You can invent custom HTML markup (for example, `<my-directive>`) to
    associate with your custom directives. You add this custom markup to HTML templates
    as if you were writing native HTML. In this way, directives become extensions of
    HTML itself.

    지시자는 다음 세 카테고리 중 하나에 속합니다:

    Directives fall into three categories:

    1. [컴포넌트](#component)는 애플리케이션 로직과 HTML 템플릿을 결합하여 애플리케이션 [뷰]를 렌더합니다.
    컴포넌트는 보통 HTML 엘리먼트들로 표현됩니다.
    Angular 앱의 중요한 구성요소로 아주 많이 사용하게 될 것입니다.

    1. [Components](#component) that combine application logic with an HTML template to
    render application [views](#view). Components are usually represented as HTML elements.
    They are the building blocks of an Angular application and the
    developer can expect to write a lot of them.

    1. [속성 지시자](#attribute-directive)는 다른 HTML 엘리먼트, 속성, 프로퍼티와 컴포넌트들의 행동을 탐지하고 변경할 수 있습니다.
    보통 HTML 속성으로 표현하기 때문에 이런 이름을 갖게 되었습니다.

    1. [Attribute directives](#attribute-directive) that can listen to and modify the behavior of
    HTML elements, components, and other directives. They are usually represented
    as HTML attributes, hence the name.

    1. [구조 지시자](#structural-directive)는 일반적으로 HTML의 요소나 자식요소들을 더하거나, 빼거나, 조작하여 HTML 레이아웃을 만들거나 수정할 때 사용합니다.

    1. [Structural directives](#structural-directive) that
    shape or reshape HTML layout, typically by adding and removing elements in the DOM.

.l-main-section#E

:marked
  ## ECMA스크립트 (ECMAScript)
  ## ECMAScript
.l-sub-section
  :marked
    [공식적인 JavaScript 언어 명세](https://en.wikipedia.org/wiki/ECMAScript)를 말합니다.
    
    The official JavaScript language specification.

    가장 최근에 정의된 JavaScript 버전은 [ECMA스크립트 2016](http://www.ecma-international.org/ecma-262/7.0/) ("ES2016" 또는 "ES7"라고도 함)입니다.
    많은 Angular 2 개발자들은 이 버전의 JavaScript를 사용하거나 또는 이 버전과 호환이 되도록 지원하고자 하는
    [타입스크립트](#typesScript)와 같은 파생언어들로 애플리케이션을 작성하게 될 것입니다.
    
    The latest approved version of JavaScript is
    [ECMAScript 2016](http://www.ecma-international.org/ecma-262/7.0/)
    (AKA "ES2016" or "ES7") and many Angular developers write their applications
    either in this version of the language or a dialect that strives to be
    compatible with it, such as [TypeScript](#typescript).

    대부분의 모던 브라우저들은 오래된 "ECMAScript 5" (AKA ES5) 표준만을 지원합니다.
    ES2016, ES2015 또는 파생언어로 작성된 애플리케이션은 ES5 JavaScript로 "[트랜스파일](#transpile)"되어야 합니다.
    
    Most modern browsers today only support the much older "ECMAScript 5" (AKA ES5) standard.
    Applications written in ES2016, ES2015 or one of their dialects must be "transpiled"
    to ES5 JavaScript.

    물론, Angular로 개발할 때 ES5를 사용하기를 선택할 수도 있습니다.
    
    Angular developers may choose to write in ES5 directly.

:marked
  ## ES2015
  ## ES2015
.l-sub-section
  :marked
    [ECMAScript](#ecmascript) 2015의 약어입니다.
    
    Short hand for ECMAScript 2015.
:marked
  ## ES6
  ## ES6
.l-sub-section
  :marked
    [ECMAScript](#ecmascript) 2015의 약어입니다.
    
    Short hand for ECMAScript 2015.
:marked
  ## ES5
  ## ES5
.l-sub-section
  :marked
    [ECMAScript](#ecmascript) 5의 약어로, 대부분의 모던 브라우저들이 지원하는 JavaScript 버전입니다.
    [ECMAScript](#ecmascript)를 참조하세요.
    
    Short hand for ECMAScript 5, the version of JavaScript run by most modern browsers.
    See ECMAScript.

a#F
a#G
a#H
.l-main-section#I
:marked
  ## 주입기 (Injector)
  ## Injector
.l-sub-section
  :marked
    Angular [의존성 주입 시스템](#dependency-injection)에 포함되는 객체이며 
    대상의 캐시 내부에서 이름지어진 "의존성"을 찾거나 기록된 [제공자](#provider)와 함께 
    특정 대상을 만들어낼 수 있습니다.
    
    An object in the Angular dependency injection system
    that can find a named "dependency" in its cache or create such a thing
    with a registered provider.
:marked
  ## 입력 (Input)
  ## Input
.l-sub-section
  :marked
    [프로퍼티 바인딩](!{docsLatest}/guide/template-syntax.html#property-binding)의 
    ***대상***이 될 수 있는 지시 프로퍼티입니다. 데이터 값은 등호 우측의 템플릿 표현에서 
    식별된 데이터 소스에서부터 프로퍼티 *내부로* 흘러갑니다.
    
    A directive property that can be the ***target*** of a
    [property binding](!{docsLatest}/guide/template-syntax.html#property-binding) (explained in detail in the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page).
    Data values flow *into* this property from the data source identified
    in the template expression to the right of the equal sign.

    [템플릿 문법](!{docsLatest}/guide/template-syntax.html#inputs-outputs)페이지의 [Input and output properties](!{docsLatest}/guide/template-syntax.html#inputs-outputs)섹션을 참고해주세오.

    See the [Input and output properties](!{docsLatest}/guide/template-syntax.html#inputs-outputs) section of the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

:marked
  ## 보간 (Interpolation)
  ## Interpolation
.l-sub-section
  :marked
    이중 중괄호 사이에서 텍스트로 렌더링되는 [템플릿 표현](#template-expression) 내부의 
    [프로퍼티 Data-Binding](#data-binding)의 형식입니다. 이 텍스트는 엘리먼트의 프로퍼티에 할당되기 
    전에 이웃 텍스트와 연결되거나 아래 예시와 같이 엘리먼트 태그들 사이에서 표시될 것입니다.
    
    A form of [property data binding](#data-binding) in which a
    [template expression](#template-expression) between double-curly braces
    renders as text.  That text may be concatenated with neighboring text
    before it is assigned to an element property
    or displayed between element tags, as in this example.

  code-example(language="html" escape="html").
    <label>My current hero is {{hero.name}}</label>
    
  :marked
    [템플릿 문법](!{docsLatest}/guide/template-syntax.html#interpolation)페이지의 [interpolation](!{docsLatest}/guide/template-syntax.html#interpolation)를 살펴보세요.

    Read more about [interpolation](!{docsLatest}/guide/template-syntax.html#interpolation) in the
    [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

.l-main-section#J

a#jit
:marked
  ## 실시간(JIT) 컴파일
  ## Just-in-time (JIT) compilation
.l-sub-section
  :marked
    Angular _실시간_ 부트스트래핑으로 여러분은 브라우저 내에 존재하는 여러분의 컴포넌트와 
    모듈을 컴파일할 수 있으며 애플리케이션을 동적으로 실행할 수 있습니다. 이는 개발 과정에서 좋은 선택지입니다. 
    상용 앱을 대상으로 할 때는 [AOT 컴파일](#aot) 모드를 권장합니다.  

    With Angular _just-in-time_  bootstrapping you compile your components<span if-docs="ts"> and modules</span> in the browser
    and launch the application dynamically. This is a good choice during development.
    Consider using the [ahead-of-time](#aot) mode for production apps.

.l-main-section#K
:marked
  ## 케밥 표기법 (kebab-case)
  ## kebab-case
.l-sub-section
  :marked
    [대시 표시법](#dash-case)을 참고하세요.
    
    See dash-case.
.l-main-section#L
:marked
  ## 생명주기 인용 (Lifecycle Hooks)
  ## Lifecycle hooks
.l-sub-section
  :marked
    [지시자](#directive)와 [컴포넌트](#component)는 Angular가 지시자와 컴포넌트를 생성하고 
    갱신하고 제거할 때, Angular의 관리를 받는 생명주기를 가집니다.

    [Directives](#directive) and [components](#component) have a lifecycle
    managed by Angular as it creates, updates, and destroys them.

    개발자들은 하나 또는 그 이상의 "생명주기 인용" 인터페이스를 구현하는 방식으로 
    특정 생명주기에서 중요한 기능을 활용할 수 있습니다.

    You can tap into key moments in that lifecycle by implementing
    one or more of the lifecycle hook interfaces.

    각각의 인터페이스는 하나의 인용 메소드를 소유하며 메소드명은 인터페이스명에서 앞부분에 `ng`가 추가된 형태입니다.
    예를 들어, `OnInit` 인터페이스는 `ngOnInit`이라는 인용 메소드를 소유합니다.

    Each interface has a single hook method whose name is the interface name prefixed with `ng`.
    For example, the `OnInit` interface has a hook method named `ngOnInit`.

    Angular는 아래와 같은 순서로 인용 메소드들을 호출합니다:
    
    Angular calls these hook methods in the following order:

    * `ngOnChanges` - [입력](#input)/[출력](#output)으로 묶인 값이 변화할 때 호출됩니다.
    * `ngOnChanges` - when an [input](#input)/[output](#output) binding value changes.

    * `ngOnInit` - 최초의 `ngOnChanges` 이후에 호출됩니다.
    * `ngOnInit` - after the first `ngOnChanges`.

    * `ngDoCheck` - 개발자가 따로 설정한 변화를 탐지하면 호출됩니다.
    * `ngDoCheck` - developer's custom change detection.

    * `ngAfterContentInit` - 컴포넌트 내용이 초기화된 이후 호출됩니다.
    * `ngAfterContentInit` - after component content initialized.

    * `ngAfterContentChecked` - 모든 컴포넌트 내용을 확인한 이후 호출됩니다.
    * `ngAfterContentChecked` - after every check of component content.

    * `ngAfterViewInit` - 컴포넌트의 (다수의) 뷰가 초기화된 이후 호출됩니다.
    * `ngAfterViewInit` - after component's view(s) are initialized.

    * `ngAfterViewChecked` - 모든 컴포넌트의 (다수의) 뷰를 확인한 이후에 호출됩니다.
    * `ngAfterViewChecked` - after every check of a component's view(s).

    * `ngOnDestroy` - 지시자가 소멸되기 직전에 호출됩니다.
    * `ngOnDestroy` - just before the directive is destroyed.
    
    [생명주기 인용](!{docsLatest}/guide/lifecycle-hooks.html)페이지에서 자세히 살펴보세요.

    Read more in the [Lifecycle Hooks](!{docsLatest}/guide/lifecycle-hooks.html) page.

.l-main-section#M

:marked
  ## 모듈 (Module)
  ## Module
.l-sub-section
  block module-defn
    .alert.is-important
      :marked
       Angular에는 두 가지 타입의 모듈이 존재합니다:
        - [Angular 모듈](#angular-module).
        세부 내용과 예시를 확인하려면 [Angular 모듈](!{docsLatest}/guide/ngmodule.html)페이지를 참조하세요.
        - 이 섹션에서 ES2015 모듈에 대해 서술되어있습니다.

       In Angular, there are two types of modules:
       - [Angular modules](#angular-module).
       For details and examples, see the [Angular Modules](!{docsLatest}/guide/ngmodule.html) page.
       - ES2015 modules, as described in this section.

    :marked
      Angular 앱은 모듈화되어있습니다.

      Angular apps are modular.

      일반적으로, 우리는 우리의 애플리케이션을 다양한 모듈(우리 스스로 작성한 것과 다른 곳에서 가져온 것들)을 혼합하여 만들었습니다.

      In general, you assemble your application from many modules, both the ones you write and the ones you acquire from others.

      모듈이란 하나의 목적만을 위한 결합력있는 코드의 블록을 의미합니다.

      A typical module is a cohesive block of code dedicated to a single purpose.
      
      모듈은 그 코드 내부의 어떤 값, 일반적으로 클래스로 구성된 하나의 대상을 **내보냅니다**.
      그 대상이 필요한 모듈은 그것을 **가져옵니다**.
      
      A module **exports** something of value in that code, typically one thing such as a class.
      A module that needs that thing, **imports** it.
      
      Angular 모듈의 구조와 import/export 문법은 
      [ES2015 모듈 표준](http://www.2ality.com/2014/09/es6-modules-final.html)에 기반을 두고 있습니다.
      
      The structure of Angular modules and the import/export syntax
      is based on the [ES2015 module standard](http://www.2ality.com/2014/09/es6-modules-final.html).

      이 표준이 추가된 애플리케이션은 요청이 발생할 때 모듈을 불러오며, 
      모듈 간 의존성을 해결하기 위해 모듈 로더를 필요로합니다. Angular는 모듈 로더를 내장하지 않으며 
      어떤 특정 서드파티 라이브러리 (거의 모든 예시자료들이 SystemJS를 사용한다 하더라도)도 포함할 계획이 없습니다. 
      애플리케이션 개발자들은 표준에 따르는 모듈 라이브러리를 선택하여 사용해야 할 것입니다.
      
      An application that adheres to this standard requires a module loader to
      load modules on request, and resolve inter-module dependencies.
      Angular does not ship with a module loader and does not have a preference
      for any particular 3rd party library (although most examples use SystemJS).
      You may pick any module library that conforms to the standard.

      모듈은 일반적으로 내보낸 대상이 정의된 파일에 따라서 명명됩니다. 추천 모듈에 포함된 
      Angular [데이터파이프](https://github.com/angular/angular/blob/master/modules/@angular/common/src/pipes/date_pipe.ts)
      클래스는 `data_pipe.ts`파일 내부에 `data_pipe`로 명명되었습니다.
      
      Modules are typically named after the file in which the exported thing is defined.
      The Angular DatePipe
      class belongs to a feature module named `date_pipe` in the file `date_pipe.ts`.

      드물게 Angular 추천 모듈을 직접 엑세스합니다.
      주로 `@angular/core`같은 Angular의 [스코프 패키지](#scoped-package)중 하나로부터 그들을 가져옵니다.
      
      You rarely access Angular feature modules directly. 
      You usually import them from one of the Angular [scoped packages](#scoped-package) such as `@angular/core`.

a#N
.l-main-section#O

+ifDocsFor('ts|js')
  :marked
    ## Observable
    ## Observable
  .l-sub-section
    :marked
      Observable은 시간의 흐름에 따라 비동기로 발생하는 데이터의 배열로 이해할 수 있습니다.
      Observable은 백엔드 서비스로부터 수신되는 정보처럼 비동기 데이터를 다룰 때 유용합니다.
      Angular의 이벤트 시스템과 http 클라이언트 서비스를 포함해서 Angular 내부에서도 Observable이 사용됩니다.
      
      You can think of an observable as an array whose items arrive asynchronously over time.
      Observables help you manage asynchronous data, such as data coming from a backend service.
      Observables are used within Angular itself, including Angular's event system and its http client service.

      Angular에서는 Observable을 사용하기 위해서 3rd 라이브러리인 Reactive Extensions (RxJS)를 사용하고 있습니다.
      Observable은 JavaScript 다음 버전인 ES 2106에 포함될 기능으로 제안된 상태입니다.

      To use observables, Angular uses a third-party library called Reactive Extensions (RxJS).
      Observables are a proposed feature for ES 2016, the next version of JavaScript.
:marked
  ## 출력 (Output)
  ## Output
.l-sub-section
  :marked
    [이벤트 바인딩(Event Binding)](!{docsLatest}/guide/template-syntax.html#property-binding)의 ***대상***이 되는 지시자의 속성입니다.
    이벤트 스트림은 이 속성에서 *출력*되어 등호 우변의 템플릿 표현식에 지정된 수신자로 전달됩니다.

    A directive property that can be the ***target*** of
    [event binding](!{docsLatest}/guide/template-syntax.html#event-binding).
    Events stream *out* of this property to the receiver identified
    in the template expression to the right of the equal sign.

    자세한 내용은 [템플릿 문법](!{docsLatest}/guide/template-syntax.html#inputs-outputs)페이지의 [input/output 속성](!{docsLatest}/guide/template-syntax.html#inputs-outputs)섹션을 참고해주세요.

    See the [Input and output properties](!{docsLatest}/guide/template-syntax.html#inputs-outputs) section of the [Template Syntax](!{docsLatest}/guide/template-syntax.html) page.

.l-main-section#P

:marked
  ## 파스칼 표기법 (PascalCase)
  ## PascalCase
.l-sub-section
  :marked
    조합된 단어나 구문을 작성할 매 단어나 약어를 대문자로 시작하는 관례를 말합니다.
    클래스(Class)명은 일반적으로 파스칼 표기법으로 작성합니다. 예를 들면 `Person`이나 `HeroDetailComponent`가 있습니다.

    The practice of writing individual words, compound words, or phrases such that each word or abbreviation begins with a capital letter. Class names are typically spelled in PascalCase. Examples include: `Person` and `HeroDetailComponent`.

    파스칼 케이스 형태는 간단히 [카멜 표기법(camelCase)](#camelcase)으로 부르는 **lower camel case**와 구분하기 위해서 **upper camel case**로 알려져 있습니다.
    이 문서에서 파스칼 표기법은 *upper camel case*이고 카멜 표기법(camelCase)은 *lower camel case*를 의미합니다.

    This form is also known as **upper camel case** to distinguish it from **lower camel case**, which is simply called [camelCase](#camelcase). In this documentation, "PascalCase" means *upper camel case* and  "camelCase" means *lower camel case*.
:marked
  ## 파이프 (Pipe)
  ## Pipe
.l-sub-section
  :marked
    Angular의 파이프(pipe)는 입력값을 [뷰(view)](#view)에 표현하기 위한 출력값으로 변환시키는 함수입니다.
    파이프함수에 이름을 부여하기 위해서 `!{_at}Pipe` !{_decoratorLink}를 사용합니다.
    이 이름이 HTML 안에서 사용되어 화면 상의 값을 선언적으로 변환합니다.

    An Angular pipe is a function that transforms input values to output values for
    display in a [view](#view). Use the `!{_at}Pipe` !{_decoratorLink}
    to associate the pipe function with a name. You then use that
    name in your HTML to declaratively transform values on screen.

    다음의 예제는 내장 파이프 `currency`를 사용하여 숫자형 값을 지역 통화로 표현하는 방법입니다.

    Here's an example that uses the built-in `currency` pipe to display
    a numeric value in the local currency.

  code-example(language="html" escape="html").
    <label>Price: </label>{{product.price | currency}}
  :marked
    자세한 내용은 [파이프(pipes)](!{docsLatest}/guide/pipes.html) 페이지에서 확인하세요.

    Read more in the page on [pipes](!{docsLatest}/guide/pipes.html).

:marked
  ## 제공자 (Provider)
  ## Provider
.l-sub-section
  :marked
    _제공자(Provider)_는 [의존성 주입(Dependency Injection)](#dependency-injection) 시스템을 위해서 새로운 의존 인스턴스를 생성합니다.
    제공자는 조회용 토큰을 소위 조리법(recipe)이라 불리우는 의존값을 생성할 수 있는 코드와 연결시킵니다.

    A _provider_ creates a new instance of a dependency for the
    [dependency injection](#dependency-injection) system.
    It relates a lookup token to code&mdash;sometimes called a "recipe"&mdash;that can create a dependency value.

a#Q
.l-main-section#R

+ifDocsFor('ts|js')
  :marked
    ## 반응형 폼 (Reactive forms)
    ## Reactive forms

  .l-sub-section
    :marked
      컴포넌트 코드를 통해 Angular 폼을 구성하는 기술.
      대안 기술로는 [템플릿 주도 폼 (Template-Driven Forms)](#template-driven-forms)이 있음.

      A technique for building Angular forms through code in a component.
      The alternate technique is Template-Driven Forms.

      반응형 폼 구성 시:
      When building reactive forms:

      - 정보의 유일한 원천은 컴포넌트입니다. 값의 검증은 컴포넌트 안의 코드에서 정의합니다.
      - The "source of truth" is the component. The validation is defined using code in the component.

      - 폼의 요소인 각 컨트롤은 컴포넌트 클래스 안에서 `new FormControl()`나 `FormBuilder`를 통해서 명시적으로 생성됩니다.
      - Each control is explicitly created in the component class with `new FormControl()` or with `FormBuilder`.

      - 템플릿의 입력 요소는 `ngModel`을 *사용하면 안 됩니다.*
      - The template input elements do *not* use `ngModel`.

      - 관련된 Angular의 지시자는 모두 `Form`을 접두어로 가진 `FormGroup`, `FormControl`, `FormControlName`이 있습니다.
      - The associated Angular directives are all prefixed with `Form` such as `FormGroup`, `FormControl`, and `FormControlName`.
      
      반응형 폼은 동적으로 폼의 컨트롤 요소를 생성해야 하는 경우처럼 좀 더 복잡한 데이터 입력 폼 시나리오를 지원하는 강력하고, 유연하며, 훌륭한 기술입니다.

      Reactive forms are powerful, flexible, and great for more complex data entry form scenarios, such as dynamic generation of form controls.
:marked
  ## 라우터 (Router)
  ## Router
.l-sub-section
  :marked
    대부분의 애플리케이션은 많은 화면 또는 [뷰(views)](#view)로 구성되어 있습니다.
    사용자는 링크 또는 버튼을 클릭하거나 이와 유사하게 애플리케이션의 뷰를 치환하는 행위를 통해서 여러 뷰를 돌아다닙니다.

    Most applications consist of many screens or [views](#view).
    The user navigates among them by clicking links and buttons,
    and performing other similar actions that cause the application to
    replace one view with another.

    Angular의 [라우터 컴포넌트(Component router)](!{docsLatest}/guide/router.html)는 뷰의 생성과 소멸을 포함하여 전체 뷰의 탐험과정의 구성과 관리를 위해
    풍부한 기능을 갖고 있습니다.

    The Angular [component router](!{docsLatest}/guide/router.html) is a richly featured mechanism for configuring and managing the entire view navigation process including the creation and destruction
    of views.
  +ifDocsFor('ts|js')
    :marked
      대부분의 경우 컴포넌트는 뷰로의 라우팅을 정의하는 `RouterConfig`를 사용하여 [라우터(router)](#router)에 포함됩니다.

      In most cases, components become attached to a [router](#router) by means
      of a `RouterConfig` that defines routes to views.

      [라우팅 컴포넌트](#routing-component)의 템플릿에는 라우터가 제공하는 뷰가 보여질 위치를 지정할 때 사용하는 `RouterOutlet` 요소를 갖고 있습니다.

      A routing component's template has a `RouterOutlet` element
      where it can display views produced by the router.

      애플리케이션의 다른 뷰는 앵커 태그나 `RouterLink` 지시자가 정의된 버튼을 사용자가 클릭하여 찾아갈 수 있을 것입니다.

      Other views in the application likely have anchor tags or buttons with `RouterLink`
      directives that users can click to navigate.

      더 자세한 내용은 [라우팅 & 내비게이션](!{docsLatest}/guide/router.html)페이지를 참고하세요.

      For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

+ifDocsFor('ts|js')
  :marked
    ## 라우터 모듈 (Router module)
    ## Router module
  .l-sub-section
    :marked
      더 자세한 내용은 [라우팅 & 내비게이션](!{docsLatest}/guide/router.html)페이지를 참고하세요.

      For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

:marked
  ## 라우팅 컴포넌트 (Routing component)
  ## Routing component
.l-sub-section
  :marked
    라우터 내비게이션을 통해서 화면에 뷰를 나타낼 RouterOutlet 을 지닌 Angular [컴포넌트](#component)

    An Angular [component](#component) with a `RouterOutlet` that displays views based on router navigations.

    더 자세한 내용은 [라우팅 & 내비게이션](!{docsLatest}/guide/router.html)페이지를 참고하세요.

    For more information, see the [Routing & Navigation](!{docsLatest}/guide/router.html) page.

.l-main-section#S

+ifDocsFor('ts|js')
  :marked
    ## Scoped package
    ## Scoped Package
  .l-sub-section
    :marked
      Angular의 모듈은 `@angular/core`, `@angular/common`, `@angular/platform-browser-dynamic`, `@angular/http`, `@angular/router`과 같이
      *Scoped Package*안에서 역할별로 나누어 배포하고 있습니다.

      Angular modules are delivered within *scoped packages* such as `@angular/core`, `@angular/common`, `@angular/platform-browser-dynamic`,
      `@angular/http`, and `@angular/router`.

      [*Scope Package*](https://docs.npmjs.com/misc/scope)는 관련 *NPM* 패키지를 하나로 구성하는 방법입니다.

      A *scoped package* is a way to group related *npm* packages.

      Scope package도 *일반* 패키지와 동일한 방식으로 임포트 합니다.
      사용자 관점에서 유일한 차이점은 Angular의 *범위 이름*인 `@angular`로 패키지명이 시작한다는 것 뿐입니다.

      You import a scoped package the same way that you'd import a *normal* package.
      The only difference, from a consumer perspective,
      is that the *scoped package* name begins with the Angular *scope name*, `@angular`.

    +makeExcerpt('architecture/ts/src/app/app.component.ts', 'import', '')

a#snake-case
:marked
  ## 스네이크 표기법(snake_case)
  ## snake_case
.l-sub-section
  block snake-case-defn
    :marked
      조합된 단어나 구문의 각 단어를 밑줄(`_`)로 구분하는 관례. 이러한 형태는 **밑줄 표기법(underscore case)**이라고도 합니다.

      The practice of writing compound words or phrases such that an
      underscore (`_`) separates one word from the next. This form is also known as **underscore case**.

:marked
  ## 서비스 (Service)
  ## Service
.l-sub-section
  :marked
    특정 뷰와 관련이 없는 데이터나 로직를 다뤄야 한다거나 혹은 컴포넌트 간 이것들을 공유하고 싶을 때 서비스를 생성하세요.

    For data or logic that is not associated
    with a specific view or that you want to share across components, build services.

    애플리케이션은 히어로 데이터 서비스나 로깅 서비스와 같은 기능을 요구할 때가 종종있습니다.
    컴포넌트는 서비스에 이러한 다루기 힘든 작업을 위임합니다.

    Applications often require services such as a hero data service or a logging service.

    서비스는 뚜렷한 목적을 지닌 클래스입니다.
    주로 어떤 뷰에도 종속되지 않는 기능을 구현하거나, 공유할 데이터를 제공하거나,
    컴포넌트 간의 로직을 제공하거나, 또는 외부와 상호작용을 감추기 위한 용도로 서비스를 생성합니다.

    A service is a class with a focused purpose.
    You often create a service to implement features that are
    independent from any specific view,
    provide shared data or logic across components, or encapsulate external interactions.

    추가적인 내용은 [Tour of Heroes](!{docsLatest}/tutorial/) 튜토리얼의 [서비스](!{docsLatest}/tutorial/toh-pt4.html)페이지를 참고하세요.
    
    For more information, see the [Services](!{docsLatest}/tutorial/toh-pt4.html) page of the [Tour of Heroes](!{docsLatest}/tutorial/) tutorial.

a#structural-directive
a#structural-directives
:marked
  ## 구조 지시자 (Structural Directive)
  ## Structural directives

.l-sub-section
  :marked
    [지사자](#directive) 유형 중 하나로 일반적으로 HTML의 요소나 자식요소들을 더하거나, 빼거나, 
    조작하여 HTML 레이아웃을 만들거나 수정할 때 사용합니다. 구조 지시자 유형의 대표적인 예로 "조건형 엘리먼트" 지시자 `ngIf`와 "반복형" 지사자 `ngFor`가 있습니다.

    A category of [directive](#directive) that can
    shape or reshape HTML layout, typically by adding and removing elements in the DOM.
    The `ngIf` "conditional element" directive and the `ngFor` "repeater" directive are well-known examples.

    추가적인 내용은 [_구조 지시자_](!{docsLatest}/guide/structural-directives.html)가이드를 참고하세요.

    Read more in the [_Structural Directives_](!{docsLatest}/guide/structural-directives.html) guide.
    
.l-main-section#T
:marked
  ## 템플릿 (Template)
  ## Template
.l-sub-section
  :marked
    템플릿은 Angular의 도움을 받아 [뷰](#view)를 렌더링할 때 쓸 HTML 덩어리입니다.
    템플릿은 [지시자](#directive)와 [컴포넌트](#component)의 도움으로 뷰를 구성합니다.

    A template is a chunk of HTML that Angular uses to render a [view](#view) with
    the support and continuing guidance of an Angular [directive](#directive),
    most notably a [component](#component).

    템플릿은 [템플릿 문법](!{docsLatest}/guide/template-syntax.html)으로 작성합니다.

    We write templates in a special Template Syntax.
+ifDocsFor('ts|js')
  :marked
    ## 템플릿 주도 폼 (Template-Driven Forms)
    ## Template-driven forms
  .l-sub-section
    :marked
      뷰에서 HTML의 폼과 입력 요소를 사용하여 Angular의 폼을 구성하는 기술.
      대안기술로 [반응형 폼(Reactive Forms)](#reactive-forms)가 있습니다.

      A technique for building Angular forms using HTML forms and input elements in the view.
      The alternate technique is Reactive Forms.

      템플릿 주도 폼 구성 시:
      When building template-driven forms:

      - 정보의 유일한 원천은 템플릿입니다. 개별 값의 검증은 입력 요소의 속성으로 정의합니다. 
      - The "source of truth" is the template. The validation is defined using attributes on the individual input elements.

      - `ngModel`로 [양방향 바인딩(Two-way binding)](#data-binding)을 선언하면 사용자가 진입 시 컴포넌트의 모델의 동기화되어 입력 요소와 동일한 값을 유지합니다.
      - [Two-way binding](#data-binding) with `ngModel` keeps the component model in synchronization with the user's entry into the input elements.

      - 내부적으로, Angular는 `name`속성을 지닌 각 입력요소마다 새로운 컨트롤을 생성하고, `name`속성과 양방향 바인딩 설정을 합니다.
      - Behind the scenes, Angular creates a new control for each input element, provided you have set up a `name` attribute and two-way binding for each input.

      - 관련된 Angular의 지시자는 모두 `ng`를 접두어로 가진 `ngForm`, `ngModel`, and `ngModelGroup`이 있습니다.
      - The associated Angular directives are all prefixed with `ng` such as `ngForm`, `ngModel`, and `ngModelGroup`.

      템플릿 주도 폼은 대부분 기본적인 데이터 초기화 폼 시나리오에 잘 맞는 편리하고 빠르며 간단한 방식입니다.

      Template-driven forms are convenient, quick, and simple. They are a good choice for many basic data entry form scenarios.

      템플릿 주도 폼을 작성하는 방법은 [폼](!{docsLatest}/guide/forms.html) 페이지를 참고하세요.

      Read about how to build template-driven forms
      in the [Forms](!{docsLatest}/guide/forms.html) page.

:marked
  ## 템플릿 표현식 (Template expression)
  ## Template expression
.l-sub-section
  :marked
    표현식은 Angular가 평가할 수 있는 [Data-Binding](#data-binding)에 !{_Lang}와 유사한 문법의 작성된 코드입니다.

    An expression is a !{_Lang}-like syntax that Angular evaluates within
    a [data binding](#data-binding).

    템플릿 표현식의 작성법은 [템플릿 문법](!{docsLatest}/guide/template-syntax.html#template-expressions)페이ㅈ를 참고하세요.

    Read about how to write template expressions
    in the [Template Syntax](!{docsLatest}/guide/template-syntax.html#template-expressions) page.

:marked
  ## 트랜스파일 (Transpile)
  ## Transpile
.l-sub-section
  :marked
    JavaScript 중 특정 형식(예를 들면 TypeScript)으로 작성된 코드를 다른 형식의 JavaScript (예를 들면 [ES5](#es5))로
    변환하는 작업

    The process of transforming code written in one form of JavaScript
    (for example, TypeScript) into another form of JavaScript  (for example, [ES5](#es5)).
 :marked
  ## TypeScript
  ## TypeScript
.l-sub-section
  :marked
    대부분의 [ECMAScript 2015](#ecmascript=2015) 언어 기능과 [데코레이터](#decorator)처럼 JavaScript의
    후속 버전에 포함될 여러 기능들을 지원하는 새로운 형식의 JavaScript 버전입니다.

    A version of JavaScript that supports most [ECMAScript 2015](#es2015)
    language features such as [decorators](#decorator).

    타입스크립트의 주목할 만한 점은 컴파일 시점의 타입검사를 할 수 있는 타입 시스템을 선택할 수 있다는 점과
    "IntelliSense, 코드 자동완성, 리팩토링, 인텔리젠트 검색과 같은 강력한 지원도구를 제공한다는 점입니다.
    대다수 코드 에디터나 IDE는 타입스크립트를 기본으로 지원하거나 플러그인 형태로 사용할 수 있습니다.

    TypeScript is also noteable for its optional typing system, which enables
    compile-time type checking and strong tooling support (for example, "intellisense",
    code completion, refactoring, and intelligent search). Many code editors
    and IDEs support TypeScript either natively or with plugins.

    타입스크립트는 Angular 개발을 위해 권장하는 언어입니다.
    [ES5](#es5)와 같이 다른 JavaScript 형식으로 작성하는 것도 환영합니다.

    TypeScript is the preferred language for Angular development although
    you can use other JavaScript dialects such as [ES5](#es5).

    타입스크립트와 관련된 내용은 [웹사이트](http://www.typescriptlang.org/)를 참고하세요.

    Read more about TypeScript at [typescript.org](http://www.typescriptlang.org/).

a#U
.l-main-section#V

:marked
  ## View
.l-sub-section
  :marked
    뷰는 클릭, 마우스 이동, 키보드 입력과 같은 사용자 행동에 대한 반응과 정보를 화면의 일부에 보여줍니다.

    A view is a portion of the screen that displays information and responds
    to user actions such as clicks, mouse moves, and keystrokes.

    Angular는 하나 또는 그 이상의 [지시자(Directive)](#directive)에 의해 뷰가 표현됩니다. 
    특히 [Component](#component) 지시자와  그것에 속한 [Templates](#template)가 그런 지시자의 역할을 합니다.
    해당 Component는 뷰 같은 구성요소를 참조하기 위해 찾는데 중요한 역할을 합니다.

    Angular renders a view under the control of one or more [directives](#directive),
    especially  [component](#component) directives and their companion [templates](#template).
    The component plays such a prominent role that it's often
    convenient to refer to a component as a view.

    뷰는 종종 다른 뷰를 포함하고, 사용자의 애플리케이션을 통한 탐색에 따라 역동적으로 로드되거나 언로드됩니다.
    이런 뷰의 특성은 일반적으로 [router](#router)의 제어에 의해 이루어집니다.

    Views often contain other views and any view might be loaded and unloaded
    dynamically as the user navigates through the application, typically
    under the control of a router.

a#W
a#X
a#Y
.l-main-section#Z

:marked
  ## 구역 (Zone)
  ## Zone
.l-sub-section
  block zone-defn
    :marked
      구역은 JavaScript 애플리케이션의 비동기 활동을 캡슐화하고 차단하기 위한 메커니즘입니다.

      Zones are a mechanism for encapsulating and intercepting
      a JavaScript application's asynchronous activity.
      
      브라우저 DOM과 JavaScript는 DOM 이벤트(클릭 이벤트 등), [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), 
      그리고 원격 서버에 보내는 [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest) 호출같이 
      제한된 수의 비동기 활동을 보유합니다.

      The browser DOM and JavaScript have a limited number
      of asynchronous activities, activities such as DOM events (for example, clicks),
      [promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise), and
      [XHR](https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest)
      calls to remote servers.

      구역은 위와같은 활동들을 모두 차단하며 "구역 클라이언트"에 비동기 활동이 종료되기 전후로 동작을 
      실행할 기회를 줍니다.

      Zones intercept all of these activities and give a "zone client" the opportunity
      to take action before and after the async activity finishes.

      Angular는 데이터의 변화를 확인하고 [Data-Binding](#data-binding)을 통해 애플리케이션이 
      보여주는 정보를 갱신함으로써 비동기 이벤트에 반응할 수 있는 구역 안에 존재하는 여러분의 
      애플리케이션을 실행합니다.

      Angular runs your application in a zone where it can respond to
      asynchronous events by checking for data changes, and updating
      the information it displays via [data bindings](#data-binding).

      [Brian Ford의 영상](https://www.youtube.com/watch?v=3IqtmUscE_U)에서 구역에 대해 더 알아보세요.
    
      Learn more about zones in this
      [Brian Ford video](https://www.youtube.com/watch?v=3IqtmUscE_U).